<!DOCTYPE html>
<html lang="en">







<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">

	<title>FFmpeg框架详解 | Pastor Dean</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="pastor">
	<meta name="description" content>

	
	<meta name="keywords" content>
	

	
	<link rel="shortcut icon" href="/images/favicon-16x16-next.png">
	<link rel="apple-touch-icon" href="/images/favicon-16x16-next.png">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="Pastor Dean">
	<meta property="og:type" content="article">
	<meta property="og:title" content="FFmpeg框架详解 | Pastor Dean">
	<meta property="og:description" content>
	<meta property="og:url" content="https://mrpastor.github.io/2019-05-27/reference/FFmpeg/FFmpeg框架函数分析/">

	
	<meta property="article:published_time" content="2019-05-27T10:05:00+08:00"> 
	<meta property="article:author" content="pastor">
	<meta property="article:published_first" content="Pastor Dean, /2019-05-27/reference/FFmpeg/FFmpeg框架函数分析/">
	

	
	
	<link rel="stylesheet" href="/css/allinonecss.min.css">

	
	
	
</head>
<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                
                <a class="site-nav-logo" href="/" title="Pastor Dean">
                    <img src="/images/favicon-32x32-next.png" alt="Pastor Dean">
                </a>
                
                
            </li>
            
            
            <li>
                <a href="/ || home" title="home">home</a>
            </li>
            
            <li>
                <a href="/categories/ || th" title="categories">categories</a>
            </li>
            
            <li>
                <a href="/archives/ || archive" title="archives">archives</a>
            </li>
            
            <li>
                <a href="/tools/ || tools" title="tools">tools</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    
    <a class="social-link" title="github" href="https://github.com/mrpastor" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    <a class="social-link" title="facebook" href="https://facebook" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

    </a>
    
    
    <a class="social-link" title="twitter" href="https://twitter.com" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

    </a>
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2019-05-27T02:14:50.000Z">
                    2019-05-27
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/FFmpeg/">FFmpeg</a>&nbsp;&nbsp;
                
                
            </div>
            <h1 class="post-full-title">FFmpeg框架详解</h1>
        </header>
        <div class="post-full no-image">
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/84499632" target="_blank" rel="noopener">[总结]FFMPEG视音频编解码零基础学习方法</a></p>
</blockquote>
<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><h2 id="FFMPEG-SDL的视频播放器"><a href="#FFMPEG-SDL的视频播放器" class="headerlink" title="FFMPEG+SDL的视频播放器"></a>FFMPEG+SDL的视频播放器</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/38868499" target="_blank" rel="noopener">最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）</a></p>
</blockquote>
<p><strong>FFmpeg 解码一个视频流程：</strong></p>
<a id="more"></a>
<p><img alt="FFmpeg解码一个视频流程" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/播放器解码的流程用图.png" data-index="0" data-src="/images/imageFFmpeg/Thor/播放器解码的流程用图.png"></p>
<p><strong>SDL2.0 显示 YUV 的流程：</strong></p>
<p><img alt="SDL2.0显示YUV的流程" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/SDL2.0显示YUV的流程图.png" data-index="1" data-src="/images/imageFFmpeg/Thor/SDL2.0显示YUV的流程图.png"></p>
<h2 id="FFMPEG的视频编码器（YUV编码为H-264）"><a href="#FFMPEG的视频编码器（YUV编码为H-264）" class="headerlink" title="FFMPEG的视频编码器（YUV编码为H.264）"></a>FFMPEG的视频编码器（YUV编码为H.264）</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/25430425" target="_blank" rel="noopener">最简单的基于FFMPEG的视频编码器（YUV编码为H.264）</a></p>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/39770947" target="_blank" rel="noopener">最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）</a></p>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/42181271" target="_blank" rel="noopener">最简单的基于FFmpeg的编码器-纯净版（不包含libavformat）</a></p>
</blockquote>
<h3 id="FFmpeg编码视频的流程图"><a href="#FFmpeg编码视频的流程图" class="headerlink" title="FFmpeg编码视频的流程图"></a>FFmpeg编码视频的流程图</h3><p>通过该流程，不仅可以编码H.264/H.265的码流，而且可以编码MPEG4/MPEG2/VP9/VP8等多种码流。实际上使用FFmpeg编码视频的方式都是一样的。图中蓝色背景的函数是实际输出数据的函数。浅绿色的函数是视频编码的函数。</p>
<p><img alt="FFmpeg编码视频的流程图" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/FFmpeg编码视频的流程图.png" data-index="2" data-src="/images/imageFFmpeg/Thor/FFmpeg编码视频的流程图.png"></p>
<p>简单介绍一下流程中各个函数的意义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">av_register_all()  <span class="comment">// 注册FFmpeg所有编解码器。</span></span><br><span class="line">avformat_alloc_output_context2()  <span class="comment">// 初始化输出码流的AVFormatContext。</span></span><br><span class="line">avio_open()  <span class="comment">// 打开输出文件。</span></span><br><span class="line">av_new_stream()  <span class="comment">// 创建输出码流的AVStream。</span></span><br><span class="line">avcodec_find_encoder()  <span class="comment">// 查找编码器。</span></span><br><span class="line">avcodec_open2()  <span class="comment">// 打开编码器。</span></span><br><span class="line">avformat_write_header()  <span class="comment">// 写文件头（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</span></span><br><span class="line">avcodec_encode_video2()  <span class="comment">// 编码一帧视频。即将AVFrame（存储YUV像素数据）编码为AVPacket（存储H.264等格式的码流数据）。</span></span><br><span class="line">av_write_frame()  <span class="comment">// 将编码后的视频码流写入文件。</span></span><br><span class="line">flush_encoder()  <span class="comment">// 输入的像素数据读取完成后调用此函数。用于输出编码器中剩余的AVPacket。</span></span><br><span class="line">av_write_trailer()  <span class="comment">// 写文件尾（对于某些没有文件头的封装格式，不需要此函数。比如说MPEG2TS）。</span></span><br></pre></td></tr></table></figure>
<h3 id="“纯净”的基于FFmpeg的视频编码器"><a href="#“纯净”的基于FFmpeg的视频编码器" class="headerlink" title="“纯净”的基于FFmpeg的视频编码器"></a>“纯净”的基于FFmpeg的视频编码器</h3><p>以下记录一个更加 “纯净” 的基于 FFmpeg 的视频编码器。此前记录过一个基于 FFmpeg 的视频编码器：</p>
<p><a href="http://blog.csdn.net/leixiaohua1020/article/details/39770947" target="_blank" rel="noopener"> 《最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）》</a></p>
<p>这个视频编码器调用了 FFmpeg 中的 libavformat 和 libavcodec 两个库完成了视频编码工作。但是这不是一个 “纯净” 的编码器。</p>
<p>上述两个库中 libavformat 完成封装格式处理，而 libavcodec 完成编码工作。</p>
<p>一个 “纯净” 的编码器，理论上说只需要使用 libavcodec 就足够了，并不需要使用 libavformat。一下记录的编码器就是这样的一个 “纯净” 的编码器，它仅仅通过调用 libavcodec 将 YUV 数据编码为 H.264/HEVC 等格式的压缩视频码流。</p>
<p><strong>仅使用libavcodec（不使用libavformat）编码视频的流程：</strong></p>
<p><img alt="仅使用libavcodec（不使用libavformat）编码视频的流程" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/仅使用libavcodec编码视频的流程.png" data-index="3" data-src="/images/imageFFmpeg/Thor/仅使用libavcodec编码视频的流程.png"></p>
<p>流程图中关键函数的作用如下所列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avcodec_register_all()  <span class="comment">// 注册所有的编解码器。</span></span><br><span class="line">avcodec_find_encoder()  <span class="comment">// 查找编码器。</span></span><br><span class="line">avcodec_alloc_context3()  <span class="comment">// 为AVCodecContext分配内存。</span></span><br><span class="line">avcodec_open2()  <span class="comment">// 打开编码器。</span></span><br><span class="line">avcodec_encode_video2()  <span class="comment">// 编码一帧数据。</span></span><br></pre></td></tr></table></figure>
<p>两个存储数据的结构体如下所列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVFrame  <span class="comment">// 存储一帧未编码的像素数据。</span></span><br><span class="line">AVPacket  <span class="comment">// 存储一帧压缩编码数据。</span></span><br></pre></td></tr></table></figure>
<p><strong>对比：</strong></p>
<p>简单记录一下这个只使用 libavcodec 的 “纯净版” 视频编码器和使用 libavcodec+libavformat 的视频编码器的不同。</p>
<p>（1）    下列与libavformat相关的函数在“纯净版”视频编码器中都不存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">av_register_all注册所有的编解码器，复用/解复用器等等组件。其中调用了</span><br><span class="line">avcodec_register_all()  <span class="comment">// 注册所有编解码器相关的组件。</span></span><br><span class="line">avformat_alloc_context()  <span class="comment">// 创建AVFormatContext结构体。</span></span><br><span class="line">avformat_alloc_output_context2()  <span class="comment">// 初始化一个输出流。</span></span><br><span class="line">avio_open()  <span class="comment">// 打开输出文件。</span></span><br><span class="line">avformat_new_stream()  <span class="comment">// 创建AVStream结构体。avformat_new_stream()中会调用</span></span><br><span class="line">avcodec_alloc_context3()  <span class="comment">// 创建AVCodecContext结构体。</span></span><br><span class="line">avformat_write_header()  <span class="comment">// 写文件头。</span></span><br><span class="line">av_write_frame()  <span class="comment">// 写编码后的文件帧。</span></span><br><span class="line">av_write_trailer()  <span class="comment">// 写文件尾。</span></span><br></pre></td></tr></table></figure>
<p>（2）    新增了如下几个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avcodec_register_all()  <span class="comment">// 只注册编解码器有关的组件。</span></span><br><span class="line">avcodec_alloc_context3()  <span class="comment">// 创建AVCodecContext结构体。</span></span><br></pre></td></tr></table></figure>
<p>可以看出，相比于“完整”的编码器，这个纯净的编码器函数调用更加简单，功能相对少一些，相对来说更加的“轻量”。</p>
<h2 id="解码框架图"><a href="#解码框架图" class="headerlink" title="解码框架图"></a>解码框架图</h2><p><img alt="FFmpeg解码" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/FFmpeg源码API结构图-解码.png" data-index="4" data-src="/images/imageFFmpeg/Thor/FFmpeg源码API结构图-解码.png"></p>
<h2 id="编码框架图"><a href="#编码框架图" class="headerlink" title="编码框架图"></a>编码框架图</h2><p><img alt="FFmpeg编码" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/FFmpeg源码API结构图-编码.png" data-index="5" data-src="/images/imageFFmpeg/Thor/FFmpeg源码API结构图-编码.png"></p>
<h1 id="通用函数解析"><a href="#通用函数解析" class="headerlink" title="通用函数解析"></a>通用函数解析</h1><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44220151" target="_blank" rel="noopener">函数解析</a></p>
</blockquote>
<h2 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all()"></a>av_register_all()</h2><p>ffmpeg 注册复用器，编码器等的函数 <code>av_register_all()</code>。该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用复用器，编码器等。</p>
<p>函数调用关系图如下图所示。<code>av_register_all()</code> 调用了 <code>avcodec_register_all()</code>。<code>avcodec_register_all()</code> 注册了和编解码器有关的组件：硬件加速器，解码器，编码器，Parser，Bitstream Filter。<code>av_register_all()</code> 除了调用 <code>avcodec_register_all()</code> 之外，还注册了复用器，解复用器，协议处理器。</p>
<p><img alt="av_register_all" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_register_all.png" data-index="6" data-src="/images/imageFFmpeg/Thor/av_register_all.png"></p>
<h2 id="内存的分配和释放（av-malloc-、av-free-等）"><a href="#内存的分配和释放（av-malloc-、av-free-等）" class="headerlink" title="内存的分配和释放（av_malloc()、av_free()等）"></a>内存的分配和释放（av_malloc()、av_free()等）</h2><p>内存操作的常见函数位于 <code>libavutil\mem.c</code> 中。本文记录FFmpeg开发中最常使用的几个函数：<code>av_malloc()</code>，<code>av_realloc()</code>，<code>av_mallocz()</code>，<code>av_calloc()</code>，<code>av_free()</code>，<code>av_freep()</code>。</p>
<p><code>av_malloc()</code> 就是简单的封装了系统函数malloc()，并做了一些错误检查工作。</p>
<h3 id="关于size-t"><a href="#关于size-t" class="headerlink" title="关于size_t"></a>关于size_t</h3><p>size _t  这个类型在 FFmpeg 中多次出现，简单解释一下其作用。size _t 是为了增强程序的可移植性而定义的。不同系统上，定义 size_t 可能不一样。它实际上就是 unsigned int。</p>
<h3 id="为什么要内存对齐？"><a href="#为什么要内存对齐？" class="headerlink" title="为什么要内存对齐？"></a>为什么要内存对齐？</h3><p>FFmpeg 内存分配方面多次涉及到 “内存对齐”（memory alignment）的概念。</p>
<p>这方面内容在 IBM 的网站上有一篇文章，讲的挺通俗易懂的，在此简单转述一下。</p>
<p>程序员通常认为内存就是一个字节数组，每次可以一个一个字节存取内存。例如在 C 语言中使用 <code>char *</code> 指代 “一块内存”，Java 中使用 <code>byte[]</code> 指代一块内存。如下所示。</p>
<p><img alt class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/内存对齐-01.png" data-index="7" data-src="/images/imageFFmpeg/Thor/内存对齐-01.png"></p>
<p>但那实际上计算机处理器却不是这样认为的。处理器相对比较 “懒惰”，它会以 2 字节，4 字节，8 字节，16 字节甚至 32 字节来存取内存。例如下图显示了以 4 字节为单位读写内存的处理器 “看待” 上述内存的方式。</p>
<p><img alt class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/内存对齐-02.png" data-index="8" data-src="/images/imageFFmpeg/Thor/内存对齐-02.png"></p>
<p>上述的存取单位的大小称之为内存存取粒度。</p>
<p>下面看一个实例，分别从地址0，和地址 1 读取 4 个字节到寄存器。</p>
<p>从程序员的角度来看，读取方式如下图所示。</p>
<p><img alt class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/内存对齐-03.png" data-index="9" data-src="/images/imageFFmpeg/Thor/内存对齐-03.png"></p>
<p>而 2 字节存取粒度的处理器的读取方式如下图所示。</p>
<p><img alt class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/内存对齐-04.png" data-index="10" data-src="/images/imageFFmpeg/Thor/内存对齐-04.png"></p>
<p>可以看出 2 字节存取粒度的处理器从地址 0 读取 4 个字节一共读取 2 次；从地址 1 读取 4 个字节一共读取了 3 次。由于每次读取的开销是固定的，因此从地址 1 读取 4 字节的效率有所下降。</p>
<p>4 字节存取粒度的处理器的读取方式如下图所示。</p>
<p><img alt class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/内存对齐-05.png" data-index="11" data-src="/images/imageFFmpeg/Thor/内存对齐-05.png"></p>
<p>可以看出 4 字节存取粒度的处理器从地址 0 读取 4 个字节一共读取 1 次；从地址 1 读取 4 个字节一共读取了 2 次。从地址 1 读取的开销比从地址 0 读取多了一倍。由此可见内存不对齐对 CPU 的性能是有影响的。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">av_malloc()  <span class="comment">// 是FFmpeg中最常见的内存分配函数, av_malloc()就是简单的封装了系统函数malloc()</span></span><br><span class="line">av_realloc()  <span class="comment">// 用于对申请的内存的大小进行调整。</span></span><br><span class="line">av_mallocz()  <span class="comment">// 可以理解为av_malloc()+zeromemory</span></span><br><span class="line">av_calloc()  <span class="comment">// 则是简单封装了av_mallocz()</span></span><br><span class="line">av_free()  <span class="comment">// 用于释放申请的内存</span></span><br><span class="line">av_freep()  <span class="comment">// 简单封装了av_free()。并且在释放内存之后将目标指针设置为NULL</span></span><br></pre></td></tr></table></figure>
<h2 id="常见结构体的初始化和销毁（AVFormatContext，AVFrame等）"><a href="#常见结构体的初始化和销毁（AVFormatContext，AVFrame等）" class="headerlink" title="常见结构体的初始化和销毁（AVFormatContext，AVFrame等）"></a>常见结构体的初始化和销毁（AVFormatContext，AVFrame等）</h2><blockquote>
<p><a href="http://blog.csdn.net/leixiaohua1020/article/details/11693997" target="_blank" rel="noopener">FFMPEG中最关键的结构体之间的关系</a></p>
</blockquote>
<p>常见的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统领全局的基本结构体。主要用于处理封装格式（FLV/MKV/RMVB 等）</span></span><br><span class="line">AVFormatContext</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入输出对应的结构体，用于输入输出（读写文件，RTMP 协议等）</span></span><br><span class="line">AVIOContext</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视音频流对应的结构体，用于视音频编解码</span></span><br><span class="line">AVStream，AVCodecContext</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储非压缩的数据（视频对应 RGB/YUV 像素数据，音频对应 PCM 采样数据）</span></span><br><span class="line">AVFrame</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储压缩数据（视频对应 H.264 等码流数据，音频对应 AAC/MP3 等码流数据）</span></span><br><span class="line">AVPacket</span><br></pre></td></tr></table></figure>
<p>他们之间的关系如下图所示：</p>
<p><img alt="常见结构体之间的关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/常见结构体之间的关系.png" data-index="12" data-src="/images/imageFFmpeg/Thor/常见结构体之间的关系.png"></p>
<p>简单分析一下上述几个结构体的初始化和销毁函数。这些函数列表如下。</p>
<table>
<thead>
<tr>
<th>结构体</th>
<th>初始化</th>
<th>销毁</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVFormatContext</td>
<td>avformat_alloc_context()</td>
<td>avformat_free_context()</td>
</tr>
<tr>
<td>AVIOContext</td>
<td>avio_alloc_context()</td>
<td></td>
</tr>
<tr>
<td>AVStream</td>
<td>avformat_new_stream()</td>
<td></td>
</tr>
<tr>
<td>AVCodecContext</td>
<td>avcodec_alloc_context3()</td>
<td></td>
</tr>
<tr>
<td>AVFrame</td>
<td>av_frame_alloc();<br>av_image_fill_arrays()</td>
<td>av_frame_free()</td>
</tr>
<tr>
<td>AVPacket</td>
<td>av_init_packet();<br>av_new_packet()</td>
<td>av_free_packet()</td>
</tr>
</tbody>
</table>
<h3 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context()"></a>avformat_alloc_context()</h3><p><code>avformat_alloc_context()</code> 的定义位于 <code>libavformat\options.c</code>。</p>
<p><code>avformat_alloc_context()</code> 调用 <code>av_malloc()</code> 为 AVFormatContext 结构体分配了内存，而且同时也给 AVFormatContext 中的 <code>internal</code> 字段分配内存（这个字段是 FFmpeg 内部使用的，先不分析）。此外调用了一个 <code>avformat_get_context_defaults()</code> 函数。该函数用于设置 AVFormatContext 的字段的默认值。它的定义也位于 <code>libavformat\options.c</code>，确切的说就位于 <code>avformat_alloc_context()</code>上面</p>
<p><code>avformat_get_context_defaults()</code> 首先调用 <code>memset()</code> 将 AVFormatContext 的所有字段置 0。而后调用了一个函数 <code>av_opt_set_defaults()</code> 。<code>av_opt_set_defaults()</code> 用于给字段设置默认值。</p>
<p><code>avformat_alloc_context()</code> 代码的函数调用关系如下图所示。</p>
<p><img alt="avformat_alloc_context" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avformat_alloc_context.png" data-index="13" data-src="/images/imageFFmpeg/Thor/avformat_alloc_context.png"></p>
<p><code>avformat_free_context()</code> 的声明位于 <code>libavformat\avformat.h</code></p>
<p><code>avformat_free_context()</code> 的定义位于 <code>libavformat\options.c</code></p>
<p><code>avformat_free_context()</code> 调用了各式各样的销毁函数：<code>av_opt_free()</code>，<code>av_freep()</code>，<code>av_dict_free()</code>。这些函数分别用于释放不同种类的变量，在这里不再详细讨论。</p>
<p>在这里看一个释放 AVStream 的函数 <code>ff_free_stream()</code>。该函数的定义位于 <code>libavformat\options.c</code>（其实就在 <code>avformat_free_context()</code> 上方）, 与释放 AVFormatContext 类似，释放 AVStream 的时候，也是调用了 <code>av_freep()</code>，<code>av_dict_free()</code> 这些函数释放有关的字段。如果使用了 parser 的话，会调用 <code>av_parser_close()</code> 关闭该 parser。</p>
<h3 id="avio-alloc-context"><a href="#avio-alloc-context" class="headerlink" title="avio_alloc_context()"></a>avio_alloc_context()</h3><p>AVIOContext 的初始化函数是 <code>avio_alloc_context()</code>，销毁的时候使用 <code>av_free()</code> 释放掉其中的缓存即可。它的声明位于 <code>libavformat\avio.h</code> 中</p>
<p><code>avio_alloc_context()</code> 定义位于 <code>libavformat\aviobuf.c</code> 中</p>
<p><code>avio_alloc_context()</code> 首先调用 <code>av_mallocz()</code> 为 AVIOContext 分配内存。而后调用了一个函数 <code>ffio_init_context()</code> 。该函数完成了真正的初始化工作</p>
<h3 id="avformat-new-stream"><a href="#avformat-new-stream" class="headerlink" title="avformat_new_stream()"></a>avformat_new_stream()</h3><p><code>avformat_new_stream()</code> 的声明位于 <code>libavformat\avformat.h</code> 中</p>
<p>AVStream 的初始化函数是 <code>avformat_new_stream()</code>，销毁函数使用销毁 AVFormatContext 的 <code>avformat_free_context()</code> 就可以了。</p>
<p><code>avformat_new_stream()</code> 的定义位于 <code>libavformat\utils.c</code> 中</p>
<p><code>avformat_new_stream()</code> 首先调用 <code>av_mallocz()</code>  为 AVStream 分配内存。接着给新分配的AVStream 的各个字段赋上默认值。然后调用了另一个函数 <code>avcodec_alloc_context3()</code> 初始化 AVStream 中的 AVCodecContext。</p>
<h3 id="avcodec-alloc-context3"><a href="#avcodec-alloc-context3" class="headerlink" title="avcodec_alloc_context3()"></a>avcodec_alloc_context3()</h3><p><code>avcodec_alloc_context3()</code> 的声明位于 <code>libavcodec\avcodec.h</code> 中</p>
<p><code>avcodec_alloc_context3()</code> 的定义位于 <code>libavcodec\options.c</code> 中</p>
<p><code>avcodec_alloc_context3()</code> 首先调用 <code>av_malloc()</code> 为 AVCodecContext 分配存储空间，然后调用了一个函数 <code>avcodec_get_context_defaults3()</code> 用于设置该 AVCodecContext 的默认值</p>
<p><code>avformat_new_stream()</code> 函数的调用结构如下所示：</p>
<p><img alt="avformat_new_stream" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avformat_new_stream.png" data-index="14" data-src="/images/imageFFmpeg/Thor/avformat_new_stream.png"></p>
<h3 id="av-frame-alloc"><a href="#av-frame-alloc" class="headerlink" title="av_frame_alloc()"></a>av_frame_alloc()</h3><p>AVFrame 的初始化函数是 <code>av_frame_alloc()</code>，销毁函数是 <code>av_frame_free()</code>。在这里有一点需要注意，旧版的 FFmpeg 都是使用 <code>avcodec_alloc_frame()</code> 初始化 AVFrame 的，但是我在写这篇文章的时候，<code>avcodec_alloc_frame()</code> 已经被标记为 “过时的” 了，为了保证与时俱进，决定分析新的<code>API——av_frame_alloc()</code>。</p>
<p><code>av_frame_alloc()</code> 的声明位于 <code>libavutil\frame.h</code></p>
<p><code>av_frame_alloc()</code> 的定义位于 <code>libavutil\frame.c</code></p>
<p><code>av_frame_alloc()</code> 首先调用 <code>av_mallocz()</code> 为 AVFrame 结构体分配内存。而后调用了一个函数<code>get_frame_defaults()</code> 用于设置一些默认参数</p>
<p>从 <code>av_frame_alloc()</code> 的代码我们可以看出，该函数并没有为 AVFrame 的像素数据分配空间。因此AVFrame 中的像素数据的空间需要自行分配空间，例如使用 <code>avpicture_fill()</code>， <code>av_image_fill_arrays()</code> 等函数。</p>
<p><code>av_frame_alloc()</code> 函数的调用结构如下所示：</p>
<p><img alt="av_frame_alloc" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_frame_alloc.png" data-index="15" data-src="/images/imageFFmpeg/Thor/av_frame_alloc.png"></p>
<h4 id="avpicture-fill"><a href="#avpicture-fill" class="headerlink" title="avpicture_fill()"></a>avpicture_fill()</h4><p><code>avpicture_fill()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p>
<p><code>avpicture_fill()</code> 的定义位于 <code>libavcodec\avpicture.c</code></p>
<p><code>avpicture_fill()</code> 仅仅是简单调用了一下 <code>av_image_fill_arrays()</code>。也就是说这两个函数实际上是等同的</p>
<h4 id="av-image-fill-arrays"><a href="#av-image-fill-arrays" class="headerlink" title="av_image_fill_arrays()"></a>av_image_fill_arrays()</h4><p><code>av_image_fill_arrays()</code> 的声明位于 <code>libavutil\imgutils.h</code> 中</p>
<p><code>av_image_fill_arrays()</code> 的定义位于 <code>libavutil\imgutils.c</code> 中</p>
<p><code>av_image_fill_arrays()</code> 函数中包含 3 个函数：<code>av_image_check_size()</code>，<code>av_image_fill_linesizes()</code>，<code>av_image_fill_pointers()</code>。<code>av_image_check_size()</code> 用于检查输入的宽高参数是否合理，即不能太大或者为负数。<code>av_image_fill_linesizes()</code> 用于填充dst_linesize。<code>av_image_fill_pointers()</code> 则用于填充 dst_data。它们的定义相对比较简单，不再详细分析。</p>
<p><code>avpicture_fill()</code> 函数调用关系如下图所示：</p>
<p><img alt="avpicture_fill" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avpicture_fill.png" data-index="16" data-src="/images/imageFFmpeg/Thor/avpicture_fill.png"></p>
<h3 id="av-init-packet"><a href="#av-init-packet" class="headerlink" title="av_init_packet()"></a>av_init_packet()</h3><p><code>av_init_packet()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p>
<p><code>av_init_packet()</code> 的定义位于 <code>libavcodec\avpacket.c</code></p>
<h3 id="av-new-packet"><a href="#av-new-packet" class="headerlink" title="av_new_packet()"></a>av_new_packet()</h3><p><code>av_new_packet()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p>
<p><code>av_new_packet()</code> 的定义位于 <code>libavcodec\avpacket.c</code></p>
<p><code>av_new_packet()</code> 调用了 <code>av_init_packet(pkt)</code>。此外还调用了一个函数 <code>packet_alloc()</code></p>
<p><code>packet_alloc()</code> 中调用 <code>av_buffer_realloc()</code> 为 AVPacket 分配内存。然后调用 <code>memset()</code> 将分配的内存置 0。</p>
<p>PS：发现 AVPacket 的结构随着 FFmpeg 的发展越发复杂了。原先 AVPacket 中的数据仅仅存在一个 uint8_t 类型的数组里，而现在已经使用一个专门的结构体 AVBufferRef 存储数据。</p>
<p><code>av_new_packet()</code> 代码的函数调用关系如下图所示：</p>
<p><img alt="av_new_packet" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_new_packet.png" data-index="17" data-src="/images/imageFFmpeg/Thor/av_new_packet.png"></p>
<p><code>av_free_packet()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p>
<p><code>av_free_packet()</code> 的定义位于 <code>libavcodec\avpacket.c</code></p>
<p><code>av_free_packet()</code> 调用 <code>av_buffer_unref()</code> 释放 AVPacket 中的数据，而后还调用了<code>av_packet_free_side_data()</code> 释放了 side_data（存储封装格式可以提供的额外的数据）。</p>
<h2 id="avio-open2"><a href="#avio-open2" class="headerlink" title="avio_open2()"></a>avio_open2()</h2><p>该函数用于打开 FFmpeg 的输入输出文件。<code>avio_open2()</code> 的声明位于 <code>libavformat\avio.h</code> 文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avio_open2</span><span class="params">(AVIOContext **s, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>avio_open2()</code> 函数参数的含义如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s：函数调用成功之后创建的AVIOContext结构体。</span><br><span class="line">url：输入输出协议的地址（文件也是一种“广义”的协议，对于文件来说就是文件的路径）。</span><br><span class="line">flags：打开地址的方式。可以选择只读，只写，或者读写。取值如下。</span><br><span class="line">AVIO_FLAG_READ：只读。</span><br><span class="line">AVIO_FLAG_WRITE：只写。</span><br><span class="line">AVIO_FLAG_READ_WRITE：读写。</span><br><span class="line">int_cb：目前还没有用过。</span><br><span class="line">options：目前还没有用过。</span><br></pre></td></tr></table></figure>
<p>函数调用结构图：</p>
<p><img alt="avio_open2" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avio_open2.png" data-index="18" data-src="/images/imageFFmpeg/Thor/avio_open2.png"></p>
<h2 id="av-find-decoder-和-av-find-encoder"><a href="#av-find-decoder-和-av-find-encoder" class="headerlink" title="av_find_decoder() 和 av_find_encoder()"></a>av_find_decoder() 和 av_find_encoder()</h2><p><code>avcodec_find_encoder()</code> 用于查找 FFmpeg 的编码器，</p>
<p><code>avcodec_find_decoder()</code> 用于查找 FFmpeg 的解码器。</p>
<p><code>avcodec_find_encoder()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_encoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的参数是一个编码器的 ID，返回查找到的编码器（没有找到就返回NULL）。</p>
<p><code>avcodec_find_decoder()</code> 的声明也位于 <code>libavcodec\avcodec.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的参数是一个解码器的 ID，返回查找到的解码器（没有找到就返回NULL）。</p>
<p><code>avcodec_find_encoder()</code> 和 <code>avcodec_find_decoder()</code> 的函数调用关系图如下所示：</p>
<p><img alt="函数调用关系图" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avcodec_find_encoder.png" data-index="19" data-src="/images/imageFFmpeg/Thor/avcodec_find_encoder.png"></p>
<p><code>avcodec_find_encoder()</code> 的源代码位于 <code>libavcodec\utils.c</code></p>
<p><code>avcodec_find_encoder()</code> 调用了一个 <code>find_encdec()</code>，注意它的第二个参数是 1。</p>
<p><code>find_encdec()</code> 的源代码位于 <code>libavcodec\utils.c</code></p>
<p><code>find_encdec()</code> 中有一个循环，该循环会遍历 AVCodec 结构的链表，逐一比较输入的 ID 和每一个编码器的 ID，直到找到 ID 取值相等的编码器。</p>
<p>在这里有几点需要注意：</p>
<p>（1）first_avcodec 是一个全局变量，存储 AVCodec 链表的第一个元素。</p>
<p>（2）<code>remap_deprecated_codec_id()</code> 用于将一些过时的编码器 ID 映射到新的编码器 ID。</p>
<p>（3）函数的第二个参数 encoder 用于确定查找编码器还是解码器。当该值为 1 的时候，用于查找编码器，此时会调用 <code>av_codec_is_encoder()</code> 判断 AVCodec 是否为编码器；当该值为 0 的时候，用于查找解码器，此时会调用 <code>av_codec_is_decoder()</code> 判断 AVCodec 是否为解码器。</p>
<p><code>avcodec_find_decoder()</code> 的源代码位于 <code>libavcodec\utils.c</code></p>
<p><code>avcodec_find_decoder()</code> 同样调用了 <code>find_encdec()</code>，只是第 2 个参数设置为 0。</p>
<h2 id="avcodec-open2"><a href="#avcodec-open2" class="headerlink" title="avcodec_open2()"></a>avcodec_open2()</h2><p>该函数用于初始化一个视音频编解码器的 AVCodecContext。</p>
<p><code>avcodec_open2()</code> 的声明位于 <code>libavcodec\avcodec.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="keyword">const</span> AVCodec *codec, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>用中文简单转述一下avcodec_open2()各个参数的含义：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avctx：需要初始化的 AVCodecContext。</span><br><span class="line">codec：输入的 AVCodec</span><br><span class="line">options：一些选项。例如使用 libx264 编码的时候，“preset”，“tune”等都可以通过该参数设置。</span><br></pre></td></tr></table></figure>
<p><code>avcodec_open2()</code> 函数调用关系非常简单，如下图所示：</p>
<p><img alt="avcodec_open2" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avcodec_open2.png" data-index="20" data-src="/images/imageFFmpeg/Thor/avcodec_open2.png"></p>
<p><code>avcodec_open2()</code> 的定义位于 <code>libavcodec\utils.c</code></p>
<p><code>avcodec_open2()</code> 的源代码量是非常长的，但是它的调用关系非常简单——它只调用了一个关键的函数，即 AVCodec 的 <code>init()</code>，后文将会对这个函数进行分析。</p>
<p>我们可以简单梳理一下 <code>avcodec_open2()</code> 所做的工作，如下所列：</p>
<p>（1）为各种结构体分配内存（通过各种 <code>av_malloc()</code> 实现）。</p>
<p>（2）将输入的 AVDictionary 形式的选项设置到 AVCodecContext。</p>
<p>（3）其他一些零零碎碎的检查，比如说检查编解码器是否处于 “实验” 阶段。</p>
<p>（4）如果是编码器，检查输入参数是否符合编码器的要求</p>
<p>（5）调用 AVCodec 的 <code>init()</code> 初始化具体的解码器。</p>
<p>前几步比较简单，不再分析。在这里我们分析一下第4步和第5步。</p>
<h3 id="检查输入参数是否符合编码器要求"><a href="#检查输入参数是否符合编码器要求" class="headerlink" title="检查输入参数是否符合编码器要求"></a>检查输入参数是否符合编码器要求</h3><p>在这里简单分析一下第 4 步，即 “检查输入参数是否符合编码器的要求”。这一步中检查了很多的参数，在这里我们随便选一个参数 pix_fmts（像素格式）看一下，如下所示。</p>
<details><summary>代码：</summary><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查像素格式</span></span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec-&gt;pix_fmts) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; avctx-&gt;codec-&gt;pix_fmts[i] != AV_PIX_FMT_NONE; i++)</span><br><span class="line">                <span class="keyword">if</span> (avctx-&gt;pix_fmt == avctx-&gt;codec-&gt;pix_fmts[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_NONE</span><br><span class="line">                &amp;&amp; !((avctx-&gt;codec_id == AV_CODEC_ID_MJPEG || avctx-&gt;codec_id == AV_CODEC_ID_LJPEG)</span><br><span class="line">                     &amp;&amp; avctx-&gt;strict_std_compliance &lt;= FF_COMPLIANCE_UNOFFICIAL)) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d"</span>, avctx-&gt;pix_fmt);</span><br><span class="line">                av_log(avctx, AV_LOG_ERROR, <span class="string">"Specified pixel format %s is invalid or not supported\n"</span>,</span><br><span class="line">                       (<span class="keyword">char</span> *)av_x_if_null(av_get_pix_fmt_name(avctx-&gt;pix_fmt), buf));</span><br><span class="line">                ret = AVERROR(EINVAL);</span><br><span class="line">                <span class="keyword">goto</span> free_and_end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||</span><br><span class="line">                avctx-&gt;codec-&gt;pix_fmts[i] == AV_PIX_FMT_YUVJ444P)</span><br><span class="line">                avctx-&gt;color_range = AVCOL_RANGE_JPEG;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br><br></details>

<p>可以看出，该代码首先进入了一个 <code>for()</code> 循环，将 AVCodecContext 中设定的 <code>pix_fmt</code> 与编码器AVCodec 中的 <code>pix_fmts</code> 数组中的元素逐一比较。</p>
<p>先简单介绍一下 AVCodec 中的 <code>pix_fmts</code> 数组。AVCodec 中的 <code>pix_fmts</code> 数组存储了该种编码器支持的像素格式，并且规定以 AV_PIX_FMT_NONE（AV_PIX_FMT_NONE 取值为 -1）为结尾。例如，libx264 的 <code>pix_fmts</code> 数组的定义位于 <code>libavcodec\libx264.c</code>，如下所示。</p>
<details><summary>代码：</summary><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat pix_fmts_8bit[] = &#123;</span><br><span class="line">    AV_PIX_FMT_YUV420P,</span><br><span class="line">    AV_PIX_FMT_YUVJ420P,</span><br><span class="line">    AV_PIX_FMT_YUV422P,</span><br><span class="line">    AV_PIX_FMT_YUVJ422P,</span><br><span class="line">    AV_PIX_FMT_YUV444P,</span><br><span class="line">    AV_PIX_FMT_YUVJ444P,</span><br><span class="line">    AV_PIX_FMT_NV12,</span><br><span class="line">    AV_PIX_FMT_NV16,</span><br><span class="line">    AV_PIX_FMT_NONE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>从 <code>pix_fmts_8bit</code> 的定义可以看出 libx264 主要支持的是以 YUV 为主的像素格式。</p>
<p>现在回到 “检查输入 <code>pix_fmt</code> 是否符合编码器的要求” 的那段代码。如果 <code>for()</code> 循环从 <code>AVCodec-&gt;pix_fmts</code> 数组中找到了符合 <code>AVCodecContext-&gt;pix_fmt</code> 的像素格式，或者完成了 <code>AVCodec-&gt;pix_fmts</code> 数组的遍历，都会跳出循环。如果发现 <code>AVCodec-&gt;pix_fmts</code> 数组中索引为 <code>i</code> 的元素是 AV_PIX_FMT_NONE（即最后一个元素，取值为 -1）的时候，就认为没有找到合适的像素格式，并且最终提示错误信息。</p>
<h3 id="AVCodec-gt-init"><a href="#AVCodec-gt-init" class="headerlink" title="AVCodec-&gt;init()"></a>AVCodec-&gt;init()</h3><p><code>avcodec_open2()</code> 中最关键的一步就是调用 AVCodec 的 <code>init()</code> 方法初始化具体的编码器。AVCodec 的 <code>init()</code> 是一个函数指针，指向具体编解码器中的初始化函数。这里我们以 libx264 为例，看一下它对应的 AVCodec 的定义。</p>
<p>libx264 对应的 AVCodec 的定义位于 <code>libavcodec\libx264.c</code></p>
<details><summary>代码：</summary><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVCodec ff_libx264_encoder = &#123;</span><br><span class="line">    .name             = <span class="string">"libx264"</span>,</span><br><span class="line">    .long_name        = NULL_IF_CONFIG_SMALL(<span class="string">"libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"</span>),</span><br><span class="line">    .type             = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id               = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size   = <span class="keyword">sizeof</span>(X264Context),</span><br><span class="line">    .init             = X264_init,</span><br><span class="line">    .encode2          = X264_frame,</span><br><span class="line">    .close            = X264_close,</span><br><span class="line">    .capabilities     = CODEC_CAP_DELAY | CODEC_CAP_AUTO_THREADS,</span><br><span class="line">    .priv_class       = &amp;x264_class,</span><br><span class="line">    .defaults         = x264_defaults,</span><br><span class="line">    .init_static_data = X264_init_static,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>可以看出在 <code>ff_libx264_encoder</code> 中 <code>init()</code> 指向 <code>X264_init()</code> 。<code>X264_init()</code> 的定义同样位于<code>libavcodec\libx264.c</code></p>
<p><code>X264_init()</code> 的代码以后研究 X264 的时候再进行细节的分析，在这里简单记录一下它做的两项工作：</p>
<p>（1）设置 X264Context 的参数。X264Context 主要完成了 libx264 和 FFmpeg 对接的功能。可以看出代码主要在设置一个 params 结构体变量，该变量的类型即是 x264 中存储参数的结构体 <code>x264_param_t</code>。<br>（2）调用 libx264 的 API 进行编码器的初始化工作。例如调用 <code>x264_param_default()</code> 设置默认参数，调用 <code>x264_param_apply_profile()</code> 设置 profile，调用 <code>x264_encoder_open()</code> 打开编码器等等。</p>
<p>最后附上 X264Context 的定义，位于 <code>libavcodec\libx264.c</code></p>
<h2 id="avcodec-close"><a href="#avcodec-close" class="headerlink" title="avcodec_close()"></a>avcodec_close()</h2><p>该函数用于关闭编码器。<code>avcodec_close()</code> 函数的声明位于 <code>libavcodec\avcodec.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_close</span><span class="params">(AVCodecContext *avctx)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数只有一个参数，就是需要关闭的编码器的 AVCodecContext。</p>
<p>函数的调用关系图如下所示：</p>
<p><img alt="avcodec_close" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avcodec_close.png" data-index="21" data-src="/images/imageFFmpeg/Thor/avcodec_close.png"></p>
<p><code>avcodec_close()</code> 的定义位于 <code>libavcodec\utils.c</code></p>
<p>从 <code>avcodec_close()</code> 的定义可以看出，该函数释放 AVCodecContext 中有关的变量，并且调用了 AVCodec 的 <code>close()</code> 关闭了解码器。</p>
<h1 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h1><h2 id="图解-FFMPEG-打开媒体的函数-avformat-open-input"><a href="#图解-FFMPEG-打开媒体的函数-avformat-open-input" class="headerlink" title="图解 FFMPEG 打开媒体的函数 avformat_open_input"></a>图解 FFMPEG 打开媒体的函数 avformat_open_input</h2><p>FFMPEG打开媒体的的过程开始于avformat_open_input，因此该函数的重要性不可忽视。</p>
<p>在该函数中，FFMPEG完成了：</p>
<ul>
<li><p>输入输出结构体 AVIOContext 的初始化；</p>
</li>
<li><p>输入数据的协议（例如 RTMP，或者 file）的识别（通过一套评分机制）:</p>
<ul>
<li>判断文件名的后缀 </li>
<li>读取文件头的数据进行比对；</li>
</ul>
</li>
<li><p>使用获得最高分的文件协议对应的 URLProtocol，通过函数指针的方式，与 FFMPEG 连接（非专业用词）；</p>
</li>
</ul>
<p>剩下的就是调用该 URLProtocol 的函数进行 open, read 等操作了</p>
<p>以下是通过 eclipse+MinGW 调试 FFMPEG 源代码获得的函数调用关系图：</p>
<p><img alt class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/图解FFMPEG打开媒体的函数avformat_open_input.png" data-index="22" data-src="/images/imageFFmpeg/Thor/图解FFMPEG打开媒体的函数avformat_open_input.png"></p>
<p>可见最终都调用了 URLProtocol 结构体中的函数指针。</p>
<p>URLProtocol 结构如下，是一大堆函数指针的集合（avio.h文件）</p>
<details><summary>代码</summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> (*url_open)(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_read)(URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int</span> (*url_write)(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_seek)(URLContext *h, <span class="keyword">int64_t</span> pos, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int</span> (*url_close)(URLContext *h);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">URLProtocol</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> (*url_read_pause)(URLContext *h, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h, <span class="keyword">int</span> stream_index,</span><br><span class="line">                             <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*url_check)(URLContext *h, <span class="keyword">int</span> mask);</span><br><span class="line">&#125; URLProtocol;</span><br></pre></td></tr></table></figure><br><br></details>

<p>URLProtocol 功能就是完成各种输入协议的读写等操作</p>
<p>但输入协议种类繁多，它是怎样做到 “大一统” 的呢？</p>
<p>原来，每个具体的输入协议都有自己对应的 URLProtocol。</p>
<p>比如 file 协议（FFMPEG 把文件也当做一种特殊的协议）（<code>*file.c</code> 文件）</p>
<details><summary>代码：</summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">URLProtocol ff_pipe_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">"pipe"</span>,</span><br><span class="line">    .url_open            = pipe_open,</span><br><span class="line">    .url_read            = file_read,</span><br><span class="line">    .url_write           = file_write,</span><br><span class="line">    .url_get_file_handle = file_get_handle,</span><br><span class="line">    .url_check           = file_check,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>或者rtmp协议（此处使用了librtmp）（librtmp.c文件）</p>
<details><summary>代码：</summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLProtocol ff_rtmp_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">"rtmp"</span>,</span><br><span class="line">    .url_open            = rtmp_open,</span><br><span class="line">    .url_read            = rtmp_read,</span><br><span class="line">    .url_write           = rtmp_write,</span><br><span class="line">    .url_close           = rtmp_close,</span><br><span class="line">    .url_read_pause      = rtmp_read_pause,</span><br><span class="line">    .url_read_seek       = rtmp_read_seek,</span><br><span class="line">    .url_get_file_handle = rtmp_get_file_handle,</span><br><span class="line">    .priv_data_size      = <span class="keyword">sizeof</span>(RTMP),</span><br><span class="line">    .flags               = URL_PROTOCOL_FLAG_NETWORK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>可见它们把各自的函数指针都赋值给了 URLProtocol 结构体的函数指针</p>
<p>因此 <code>avformat_open_input</code> 只需调用 url_open, url_read 这些函数就可以完成各种具体输入协议的 open, read 等操作了</p>
<h2 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input()"></a>avformat_open_input()</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/11885813" target="_blank" rel="noopener">FFMPEG源码分析：avformat_open_input()（媒体打开函数）</a></p>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44064715" target="_blank" rel="noopener">avformat_open_input()</a></p>
</blockquote>
<p>个人感觉这个函数确实太重要了，可以算作 FFmpeg 的 “灵魂”</p>
<p>函数用于打开多媒体数据并且获得一些相关的信息。它的声明位于 <code>libavformat\avformat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *filename, AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps：函数调用成功之后处理过的 AVFormatContext 结构体。</span><br><span class="line">file：打开的视音频流的 URL。</span><br><span class="line">fmt：强制指定 AVFormatContext 中 AVInputFormat 的。这个参数一般情况下可以设置为 NULL，这样 FFmpeg 可以自动检测 AVInputFormat。</span><br><span class="line">dictionay：附加的一些选项，一般情况下可以设置为 NULL。</span><br></pre></td></tr></table></figure>
<p>函数执行成功的话，其返回值大于等于 0。</p>
<p>函数调用结构图如下所示：</p>
<p><img alt="avformat_open_input" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avformat_open_input.png" data-index="23" data-src="/images/imageFFmpeg/Thor/avformat_open_input.png"></p>
<p><code>avformat_open_input()</code> 定义位于 <code>libavformat\utils.c</code> 中</p>
<p><code>avformat_open_input()</code> 源代码比较长，一部分是一些容错代码，比如说如果发现传入的 AVFormatContext 指针没有初始化过，就调用 <code>avformat_alloc_context()</code> 初始化该结构体；还有一部分是针对一些格式做的特殊处理，比如 id3v2 信息的处理等等。有关上述两种信息不再详细分析，在这里只选择它关键的两个函数进行分析：</p>
<ul>
<li><p><strong><code>init_input()</code></strong>：绝大部分初始化工作都是在这里做的。</p>
</li>
<li><p><strong><code>s-&gt;iformat-&gt;read_header()</code></strong>：读取多媒体数据文件头，根据视音频流创建相应的 AVStream。</p>
</li>
</ul>
<h3 id="init-input"><a href="#init-input" class="headerlink" title="init_input()"></a>init_input()</h3><p><code>init_input()</code> 作为一个内部函数，竟然包含了一行注释（一般内部函数都没有注释），足可以看出它的重要性。它的主要工作就是打开输入的视频数据并且探测视频的格式。该函数的定义位于 <code>libavformat\utils.c</code></p>
<details><summary>代码：</summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Open input file and probe the format if necessary. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                      AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVProbeData pd = &#123; filename, <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;iformat)</span><br><span class="line">            <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                         s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)</span><br><span class="line">            av_log(s, AV_LOG_WARNING, <span class="string">"Custom AVIOContext makes no sense and "</span></span><br><span class="line">                                      <span class="string">"will be ignored with AVFMT_NOFILE format.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">        (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = av_probe_input_format2(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((ret = avio_open2(&amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags,</span><br><span class="line">                          &amp;s-&gt;interrupt_callback, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                 s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<p>这个函数在短短的几行代码中包含了好几个 return，因此逻辑还是有点复杂的，我们可以梳理一下：</p>
<p>在函数的开头的 score 变量是一个判决 AVInputFormat 的分数的门限值，如果最后得到的 AVInputFormat 的分数低于该门限值，就认为没有找到合适的 AVInputFormat 。</p>
<p>FFmpeg 内部判断封装格式的原理实际上是对每种 AVInputFormat 给出一个分数，满分是 100 分，越有可能正确的 AVInputFormat 给出的分数就越高。最后选择分数最高的 AVInputFormat 作为推测结果。score 的值是一个宏定义 AVPROBE_SCORE_RETRY，我们可以看一下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)</span></span><br></pre></td></tr></table></figure>
<p>其中 AVPROBE_SCORE_MAX 是 score 的最大值，取值是 100：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVPROBE_SCORE_MAX       100 <span class="comment">///&lt; maximum score</span></span></span><br></pre></td></tr></table></figure>
<p>由此我们可以得出 score 取值是 25，即如果推测后得到的最佳 AVInputFormat 的分值低于 25，就认为没有找到合适的 AVInputFormat。</p>
<p>整个函数的逻辑大体如下：</p>
<p>（1）当使用了自定义的 AVIOContext 的时候（AVFormatContext 中的 AVIOContext 不为空，即 <code>s-&gt;pb!=NULL</code>），如果指定了 AVInputFormat 就直接返回，如果没有指定就调用 <code>av_probe_input_buffer2()</code> 推测 AVInputFormat。这一情况出现的不算很多，但是当我们从内存中读取数据的时候（需要初始化自定义的 AVIOContext），就会执行这一步骤。</p>
<p>（2）在更一般的情况下，如果已经指定了 AVInputFormat，就直接返回；如果没有指定 AVInputFormat，就调用 <code>av_probe_input_format(NULL,…)</code> 根据文件路径判断文件格式。这里特意把 <code>av_probe_input_format()</code> 的第 1 个参数写成 “NULL”，是为了强调这个时候实际上并没有给函数提供输入数据，此时仅仅通过文件路径推测 AVInputFormat。</p>
<p>（3）如果发现通过文件路径判断不出来文件格式，那么就需要打开文件探测文件格式了，这个时候会首先调用 <code>avio_open2()</code> 打开文件，然后调用 <code>av_probe_input_buffer2()</code> 推测 AVInputFormat。</p>
<h2 id="avformat-find-stream-info"><a href="#avformat-find-stream-info" class="headerlink" title="avformat_find_stream_info()"></a>avformat_find_stream_info()</h2><p>该函数可以读取一部分视音频数据并且获得一些相关的信息。</p>
<p><code>avformat_find_stream_info()</code> 的声明位于 <code>libavformat\avformat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简单解释一下它的参数的含义：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic：输入的 AVFormatContext。</span><br><span class="line">options：额外的选项，目前没有深入研究过。</span><br></pre></td></tr></table></figure>
<p>函数正常执行后返回值大于等于 0。</p>
<p>PS：由于该函数比较复杂，所以只看了一部分代码，以后有时间再进一步分析。</p>
<p>函数的调用关系如下图所示：</p>
<p><img alt="avformat_find_stream_info" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avformat_find_stream_info.png" data-index="24" data-src="/images/imageFFmpeg/Thor/avformat_find_stream_info.png"></p>
<p><code>avformat_find_stream_info()</code> 的定义位于 <code>libavformat\utils.c</code></p>
<p>由于<code>avformat_find_stream_info()</code> 代码比较长，难以全部分析，在这里只能简单记录一下它的要点。该函数主要用于给每个媒体流（音频/视频）的 AVStream 结构体赋值。我们大致浏览一下这个函数的代码，会发现它其实已经实现了解码器的查找，解码器的打开，视音频帧的读取，视音频帧的解码等工作。换句话说，该函数实际上已经“走通”的解码的整个流程。下面看一下除了成员变量赋值之外，该函数的几个关键流程。</p>
<ul>
<li><p>查找解码器：<code>find_decoder()</code></p>
</li>
<li><p>打开解码器：<code>avcodec_open2()</code></p>
</li>
<li><p>读取完整的一帧压缩编码的数据：<code>read_frame_internal()</code></p>
<p>注：<code>av_read_frame()</code> 内部实际上就是调用的 <code>read_frame_internal()</code>。</p>
</li>
<li><p>解码一些压缩编码数据：<code>try_decode_frame()</code></p>
</li>
</ul>
<h2 id="av-read-frame"><a href="#av-read-frame" class="headerlink" title="av_read_frame()"></a>av_read_frame()</h2><p>ffmpeg 中的 <code>av_read_frame()</code> 的作用是读取码流中的音频若干帧或者视频一帧。例如，解码视频的时候，每解码一个视频帧，需要先调用 <code>av_read_frame()</code> 获得一帧视频的压缩数据，然后才能对该数据进行解码（例如 H.264 中一帧压缩数据通常对应一个 NAL）。</p>
<p>上代码之前，先参考了其他人对 <code>av_read_frame()</code> 的解释，在此做一个参考：</p>
<blockquote>
<p>通过 <code>av_read_packet()</code>，读取一个包，需要说明的是此函数必须是包含整数帧的，不存在半帧的情况，以 ts 流为例，是读取一个完整的 PES 包（一个完整 pes 包包含若干视频或音频 es 包），读取完毕后，通过 <code>av_parser_parse2()</code> 分析出视频一帧（或音频若干帧），返回，下次进入循环的时候，如果上次的数据没有完全取完，则 <code>st = s-&gt;cur_st</code> ; 不会是 NULL，即再此进入 <code>av_parser_parse2()</code> 流程，而不是下面的 <code>av_read_packet（）</code> 流程，这样就保证了，如果读取一次包含了 N 帧视频数据（以视频为例），则调用 <code>av_read_frame（）</code> N 次都不会去读数据，而是返回第一次读取的数据，直到全部解析完毕。</p>
</blockquote>
<p><code>av_read_frame()</code> 的声明位于 <code>libavformat\avformat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>av_read_frame()</code> 使用方法在注释中写得很详细，用中文简单描述一下它的两个参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s：输入的AVFormatContext</span><br><span class="line">pkt：输出的AVPacket</span><br></pre></td></tr></table></figure>
<p>如果返回 0 则说明读取正常。</p>
<p>函数调用结构图如下所示：</p>
<p><img alt="av_read_frame" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_read_frame.png" data-index="25" data-src="/images/imageFFmpeg/Thor/av_read_frame.png"></p>
<p><code>av_read_frame()</code> 的定义位于 <code>libavformat\utils.c</code></p>
<p><code>read_frame_internal()</code> 代码比较长，这里只简单看一下它前面的部分。它前面部分有 2 步是十分关键的：</p>
<p>（1）调用了 <code>ff_read_packet()</code> 从相应的 AVInputFormat 读取数据。</p>
<p>（2）如果媒体频流需要使用 AVCodecParser，则调用 <code>parse_packet()</code> 解析相应的 AVPacket。</p>
<p><code>ff_read_packet()</code> 中最关键的地方就是调用了 AVInputFormat 的 <code>read_packet()</code> 方法。 AVInputFormat 的 <code>read_packet()</code> 是一个函数指针，指向当前的 AVInputFormat 的读取数据的函数。在这里我们以 FLV 封装格式对应的 AVInputFormat 为例，看看 <code>read_packet()</code> 的实现函数是什么样子的。</p>
<p>FLV 封装格式对应的 AVInputFormat 的定义位于 <code>libavformat\flvdec.c</code></p>
<details><summary>代码：</summary><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AVInputFormat ff_flv_demuxer = &#123;</span><br><span class="line">    .name           = <span class="string">"flv"</span>,</span><br><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL(<span class="string">"FLV (Flash Video)"</span>),</span><br><span class="line">    .priv_data_size = <span class="keyword">sizeof</span>(FLVContext),</span><br><span class="line">    .read_probe     = flv_probe,</span><br><span class="line">    .read_header    = flv_read_header,</span><br><span class="line">    .read_packet    = flv_read_packet,</span><br><span class="line">    .read_seek      = flv_read_seek,</span><br><span class="line">    .read_close     = flv_read_close,</span><br><span class="line">    .extensions     = <span class="string">"flv"</span>,</span><br><span class="line">    .priv_class     = &amp;flv_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>从 <code>ff_flv_demuxer</code> 的定义可以看出，<code>read_packet()</code> 对应的是 <code>flv_read_packet()</code> 函数。在看 <code>flv_read_packet()</code> 函数之前，我们先回顾一下 FLV 封装格式的结构，如下图所示。</p>
<p>PS：原图是网上找的，感觉画的很清晰，比官方的 Video File Format Specification 更加通俗易懂。但是图中有一个错误，就是 TagHeader 中的 StreamID 字段的长度写错了（查看了一下官方标准，应该是 3 字节，现在已经改过来了）。</p>
<p><img alt="FLV封装格式" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/FLV封装格式.png" data-index="26" data-src="/images/imageFFmpeg/Thor/FLV封装格式.png"></p>
<p>从图中可以看出，FLV 文件体部分是由一个一个的 Tag 连接起来的（中间间隔着 Previous Tag Size）。每个 Tag 包含了 Tag Header 和 Tag Data 两个部分。</p>
<p>Tag Data 根据 Tag 的 Type 不同而不同：可以分为音频 Tag Data，视频 Tag Data 以及 Script Tag Data。下面简述一下音频 Tag Data 和视频 Tag Data。</p>
<h3 id="Audio-Tag-Data"><a href="#Audio-Tag-Data" class="headerlink" title="Audio Tag Data"></a>Audio Tag Data</h3><p>Audio Tag在官方标准中定义如下。</p>
<p><img alt="Audio Tag" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/AudioTag.png" data-index="27" data-src="/images/imageFFmpeg/Thor/AudioTag.png"></p>
<p>Audio Tag 开始的第 1 个字节包含了音频数据的参数信息，从第 2 个字节开始为音频流数据。<br>第 1 个字节的前 4 位的数值表示了音频数据格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 = Linear PCM, platform endian</span><br><span class="line">1 = ADPCM</span><br><span class="line">2 = MP3</span><br><span class="line">3 = Linear PCM, little endian</span><br><span class="line">4 = Nellymoser 16-kHz mono</span><br><span class="line">5 = Nellymoser 8-kHz mono</span><br><span class="line">6 = Nellymoser</span><br><span class="line">7 = G.711 A-law logarithmic PCM</span><br><span class="line">8 = G.711 mu-law logarithmic PCM</span><br><span class="line">9 = reserved</span><br><span class="line">10 = AAC</span><br><span class="line">14 = MP3 8-Khz</span><br><span class="line">15 = Device-specific sound</span><br></pre></td></tr></table></figure>
<p>第 1 个字节的第 5-6 位的数值表示采样率：<code>0 = 5.5kHz，1 = 11KHz，2 = 22 kHz，3 = 44 kHz</code>。</p>
<p>第 1 个字节的第7位表示采样精度：<code>0 = 8bits，1 = 16bits</code>。</p>
<p>第 1 个字节的第8位表示音频类型：<code>0 = sndMono，1 = sndStereo</code>。</p>
<p>其中，当音频编码为 AAC 的时候，第一个字节后面存储的是 AACAUDIODATA，格式如下所示。</p>
<p><img alt="AACAUDIODATA格式" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/AACAUDIODATA格式.png" data-index="28" data-src="/images/imageFFmpeg/Thor/AACAUDIODATA格式.png"></p>
<h3 id="Video-Tag-Data"><a href="#Video-Tag-Data" class="headerlink" title="Video Tag Data"></a>Video Tag Data</h3><p>Video Tag在官方标准中的定义如下：</p>
<p><img alt="Video Tag" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/VideoTag.png" data-index="29" data-src="/images/imageFFmpeg/Thor/VideoTag.png"></p>
<p>Video Tag 也用开始的第 1 个字节包含视频数据的参数信息，从第 2 个字节为视频流数据。</p>
<p>第 1 个字节的前 4 位的数值表示帧类型（FrameType）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: keyframe (for AVC, a seekableframe)（关键帧）</span><br><span class="line">2: inter frame (for AVC, a nonseekableframe)</span><br><span class="line">3: disposable inter frame (H.263only)</span><br><span class="line">4: generated keyframe (reservedfor server use only)</span><br><span class="line">5: video info/command frame</span><br></pre></td></tr></table></figure>
<p>第 1 个字节的后 4 位的数值表示视频编码 ID（CodecID）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1: JPEG (currently unused)</span><br><span class="line">2: Sorenson H.263</span><br><span class="line">3: Screen video</span><br><span class="line">4: On2 VP6</span><br><span class="line">5: On2 VP6 with alpha channel</span><br><span class="line">6: Screen video version 2</span><br><span class="line">7: AVC</span><br></pre></td></tr></table></figure>
<p>其中，当音频编码为 AVC（H.264）的时候，第一个字节后面存储的是 AVCVIDEOPACKET，格式如下所示。</p>
<p><img alt="AVCVIDEOPACKET格式" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/AVCVIDEOPACKET格式.png" data-index="30" data-src="/images/imageFFmpeg/Thor/AVCVIDEOPACKET格式.png"></p>
<p>了解了 FLV 的基本格式之后，就可以看一下 FLV 解析 Tag 的函数 <code>flv_read_packet()了</code>。</p>
<p><code>flv_read_packet()</code> 的定义位于 <code>libavformat\flvdec.c</code></p>
<p><code>flv_read_packet()</code> 的代码比较长，但是逻辑比较简单。它的主要功能就是根据 FLV 文件格式的规范，逐层解析 Tag 以及 TagData，获取 Tag 以及 TagData 中的信息。比较关键的地方已经写上了注释，不再详细叙述。</p>
<p><code>parse_packet()</code> 给需要 AVCodecParser 的媒体流提供解析 AVPacket 的功能。</p>
<p>从代码中可以看出，最终调用了相应 AVCodecParser 的 <code>av_parser_parse2()</code> 函数，解析出来 AVPacket。此后根据解析的信息还进行了一系列的赋值工作，不再详细叙述。</p>
<h2 id="avcodec-decode-video2"><a href="#avcodec-decode-video2" class="headerlink" title="avcodec_decode_video2()"></a>avcodec_decode_video2()</h2><p>ffmpeg 中的 <code>avcodec_decode_video2()</code> 的作用是解码一帧视频数据。输入一个压缩编码的结构体 AVPacket，输出一个解码后的结构体 AVFrame。该函数的声明位于 <code>libavcodec\avcodec.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_decode_video2</span><span class="params">(AVCodecContext *avctx, AVFrame *picture,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> *got_picture_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> AVPacket *avpkt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>查看源代码之后发现，这个函数竟然十分的简单，源代码位于 <code>libavcodec\utils.c</code></p>
<p>从代码中可以看出，<code>avcodec_decode_video2()</code> 主要做了以下几个方面的工作：</p>
<p>（1）对输入的字段进行了一系列的检查工作：例如宽高是否正确，输入是否为视频等等。</p>
<p>（2）通过 <code>ret = avctx-&gt;codec-&gt;decode(avctx, picture, got_picture_ptr,&amp;tmp)</code> 这句代码，调用了相应 AVCodec 的 <code>decode()</code> 函数，完成了解码操作。</p>
<p>（3）对得到的 AVFrame 的一些字段进行了赋值，例如宽高、像素格式等等。</p>
<p>其中第二部是关键的一步，它调用了 AVCodec 的 <code>decode()</code> 方法完成了解码。AVCodec 的 <code>decode()</code> 方法是一个函数指针，指向了具体解码器的解码函数。在这里我们以 H.264 解码器为例，看一下解码的实现过程。H.264 解码器对应的 AVCodec 的定义位于 <code>libavcodec\h264.c</code>，如下所示。</p>
<details><summary>代码：</summary><br><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AVCodec ff_h264_decoder = &#123;</span><br><span class="line">    .name                  = <span class="string">"h264"</span>,</span><br><span class="line">    .long_name             = NULL_IF_CONFIG_SMALL(<span class="string">"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"</span>),</span><br><span class="line">    .type                  = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id                    = AV_CODEC_ID_H264,</span><br><span class="line">    .priv_data_size        = <span class="keyword">sizeof</span>(H264Context),</span><br><span class="line">    .init                  = ff_h264_decode_init,</span><br><span class="line">    .close                 = h264_decode_end,</span><br><span class="line">    .decode                = h264_decode_frame,</span><br><span class="line">    .capabilities          = <span class="comment">/*CODEC_CAP_DRAW_HORIZ_BAND |*/</span> CODEC_CAP_DR1 |</span><br><span class="line">                             CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS |</span><br><span class="line">                             CODEC_CAP_FRAME_THREADS,</span><br><span class="line">    .flush                 = flush_dpb,</span><br><span class="line">    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),</span><br><span class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),</span><br><span class="line">    .profiles              = NULL_IF_CONFIG_SMALL(profiles),</span><br><span class="line">    .priv_class            = &amp;h264_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>从 <code>ff_h264_decoder</code> 的定义可以看出，<code>decode()</code> 指向了 <code>h264_decode_frame()</code> 函数。</p>
<p>从 <code>h264_decode_frame()</code> 的定义可以看出，它调用了 <code>decode_nal_units()</code> 完成了具体的 H.264 解码工作。</p>
<h2 id="avformat-close-input"><a href="#avformat-close-input" class="headerlink" title="avformat_close_input()"></a>avformat_close_input()</h2><p>该函数用于关闭一个 AVFormatContext，一般情况下是和 <code>avformat_open_input()</code> 成对使用的。</p>
<p>函数的调用关系如下图所示：</p>
<p><img alt="avformat_close_input" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avformat_close_input.png" data-index="31" data-src="/images/imageFFmpeg/Thor/avformat_close_input.png"></p>
<p><code>avformat_close_input()</code> 的源代码位于 <code>libavformat\utils.c</code></p>
<p>从源代码中可以看出，<code>avformat_close_input()</code> 主要做了以下几步工作：</p>
<p>（1）调用 AVInputFormat 的 <code>read_close()</code> 方法关闭输入流</p>
<p>（2）调用 <code>avformat_free_context()</code> 释放 AVFormatContext</p>
<p>（3）调用 <code>avio_close()</code> 关闭并且释放 AVIOContext</p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="avformat-alloc-output-context2"><a href="#avformat-alloc-output-context2" class="headerlink" title="avformat_alloc_output_context2()"></a>avformat_alloc_output_context2()</h2><p>在基于 FFmpeg 的视音频编码器程序中，该函数通常是第一个调用的函数（除了组件注册函数 <code>av_register_all()</code>）。</p>
<p><code>avformat_alloc_output_context2()</code> 函数可以初始化一个用于输出的 AVFormatContext 结构体。它的声明位于 <code>libavformat\avformat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_alloc_output_context2</span><span class="params">(AVFormatContext **ctx, AVOutputFormat *oformat,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">char</span> *format_name, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>
<p>代码中的英文注释写的已经比较详细了，在这里拿中文简单叙述一下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx：函数调用成功之后创建的AVFormatContext结构体。</span><br><span class="line">oformat：指定AVFormatContext中的AVOutputFormat，用于确定输出格式。如果指定为NULL，可以设定后两个参数（format_name或者filename）由FFmpeg猜测输出格式。</span><br><span class="line">PS：使用该参数需要自己手动获取AVOutputFormat，相对于使用后两个参数来说要麻烦一些。</span><br><span class="line">format_name：指定输出格式的名称。根据格式名称，FFmpeg会推测输出格式。输出格式可以是“flv”，“mkv”等等。</span><br><span class="line">filename：指定输出文件的名称。根据文件名称，FFmpeg会推测输出格式。文件名称可以是“xx.flv”，“yy.mkv”等等。</span><br></pre></td></tr></table></figure>
<p>函数执行成功的话，其返回值大于等于0。</p>
<p>首先贴出来最终分析得出的函数调用结构图，如下所示：</p>
<p><img alt="avformat_alloc_output_context2" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avformat_alloc_output_context2.png" data-index="32" data-src="/images/imageFFmpeg/Thor/avformat_alloc_output_context2.png"></p>
<p><code>avformat_alloc_output_context2()</code> 的函数定义位于 <code>libavformat\mux.c</code></p>
<p>从代码中可以看出，<code>avformat_alloc_output_context2()</code> 的流程如要包含以下 2 步：</p>
<p>1)    调用 <code>avformat_alloc_context()</code> 初始化一个默认的 AVFormatContext。</p>
<p>2)    如果指定了输入的 AVOutputFormat，则直接将输入的 AVOutputFormat 赋值给AVOutputFormat 的 oformat。如果没有指定输入的 AVOutputFormat，就需要根据文件格式名称或者文件名推测输出的 AVOutputFormat。无论是通过文件格式名称还是文件名推测输出格式，都会调用一个函数 <code>av_guess_format()</code>。</p>
<p><code>avformat_alloc_context()</code> 首先调用 <code>av_malloc()</code> 为 AVFormatContext 分配一块内存。然后调用了一个函数 <code>avformat_get_context_defaults()</code> 用于给 AVFormatContext 设置默认值</p>
<p><code>avformat_alloc_context()</code> 首先调用 <code>memset()</code> 将 AVFormatContext 的内存置零；然后指定它的AVClass（指定了 AVClass 之后，该结构体就支持和 AVOption 相关的功能）；最后调用 <code>av_opt_set_defaults()</code> 给 AVFormatContext 的成员变量设置默认值（<code>av_opt_set_defaults()</code> 就是和 AVOption 有关的一个函数，专门用于给指定的结构体设定默认值，此处暂不分析）。</p>
<p><code>av_guess_format()</code> 中使用一个整型变量 score 记录每种输出格式的匹配程度。函数中包含了一个 <code>while()</code> 循环，该循环利用函数 <code>av_oformat_next()</code> 遍历 FFmpeg 中所有的 AVOutputFormat，并逐一计算每个输出格式的 score。具体的计算过程分成如下几步：</p>
<p>1)    如果封装格式名称匹配，score 增加 100。匹配中使用了函数 <code>av_match_name()</code>。</p>
<p>2)    如果 mime 类型匹配，score 增加 10。匹配直接使用字符串比较函数 <code>strcmp()</code>。</p>
<p>3)    如果文件名称的后缀匹配，score 增加 5。匹配中使用了函数 <code>av_match_ext()</code>。</p>
<p><code>while()</code> 循环结束后，得到得分最高的格式，就是最匹配的格式。</p>
<p>下面看一下一个 AVOutputFormat 的实例，就可以理解 “封装格式名称”，“mine类型”，“文件名称后缀” 这些概念了。下面是 flv 格式的视音频复用器（Muxer）对应的 AVOutputFormat 格式的变量 <code>ff_flv_muxer</code>。</p>
<details><summary>代码：</summary><br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AVOutputFormat ff_flv_muxer = &#123;</span><br><span class="line">    .name           = <span class="string">"flv"</span>,</span><br><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL(<span class="string">"FLV (Flash Video)"</span>),</span><br><span class="line">    .mime_type      = <span class="string">"video/x-flv"</span>,</span><br><span class="line">    .extensions     = <span class="string">"flv"</span>,</span><br><span class="line">    .priv_data_size = <span class="keyword">sizeof</span>(FLVContext),</span><br><span class="line">    .audio_codec    = CONFIG_LIBMP3LAME ? AV_CODEC_ID_MP3 : AV_CODEC_ID_ADPCM_SWF,</span><br><span class="line">    .video_codec    = AV_CODEC_ID_FLV1,</span><br><span class="line">    .write_header   = flv_write_header,</span><br><span class="line">    .write_packet   = flv_write_packet,</span><br><span class="line">    .write_trailer  = flv_write_trailer,</span><br><span class="line">    .codec_tag      = (<span class="keyword">const</span> AVCodecTag* <span class="keyword">const</span> []) &#123;</span><br><span class="line">                          flv_video_codec_ids, flv_audio_codec_ids, <span class="number">0</span></span><br><span class="line">                      &#125;,</span><br><span class="line">    .flags          = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS |</span><br><span class="line">                      AVFMT_TS_NONSTRICT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<h2 id="avformat-write-header"><a href="#avformat-write-header" class="headerlink" title="avformat_write_header()"></a>avformat_write_header()</h2><p>FFmpeg 的写文件用到的 3 个函数：</p>
<ul>
<li><strong><code>avformat_write_header()</code></strong></li>
<li><strong><code>av_write_frame()</code></strong></li>
<li><strong><code>av_write_trailer()</code></strong></li>
</ul>
<p>其中 <code>av_write_frame()</code> 用于写视频数据，<code>avformat_write_header()</code> 用于写视频文件头，而 <code>av_write_trailer()</code> 用于写视频文件尾。</p>
<p>本文首先分析<code>avformat_write_header()</code>。</p>
<p>PS：需要注意的是，尽管这 3 个函数功能是配套的，但是它们的前缀却不一样，写文件头 Header 的函数前缀是“<code>avformat_</code>”，其他两个函数前缀是“<code>av_</code>”（不太明白其中的原因）。</p>
<p><code>avformat_write_header()</code> 的声明位于 <code>libavformat\avformat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_write_header</span><span class="params">(AVFormatContext *s, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简单解释一下它的参数的含义：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s：用于输出的AVFormatContext。</span><br><span class="line">options：额外的选项，目前没有深入研究过，一般为NULL。</span><br></pre></td></tr></table></figure>
<p>函数正常执行后返回值等于 0。</p>
<p><code>avformat_write_header()</code> 的调用关系如下图所示：</p>
<p><img alt="avformat_write_header" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/avformat_write_header.png" data-index="33" data-src="/images/imageFFmpeg/Thor/avformat_write_header.png"></p>
<p><code>avformat_write_header()</code> 的定义位于 <code>libavformat\mux.c</code></p>
<p>从源代码可以看出，<code>avformat_write_header()</code> 完成了以下工作：</p>
<p>（1）调用 <code>init_muxer()</code> 初始化复用器</p>
<p>（2）调用 AVOutputFormat 的 <code>write_header()</code></p>
<p><code>init_muxer()</code> 代码很长，但是它所做的工作比较简单，可以概括成两个字：检查。函数的流程可以概括成以下几步：</p>
<p>（1）将传入的 AVDictionary 形式的选项设置到 AVFormatContext</p>
<p>（2）遍历 AVFormatContext 中的每个 AVStream，并作如下检查：</p>
<ul>
<li>a) AVStream 的 time_base 是否正确设置。如果发现 AVStream 的 time_base 没有设置，则会调用 <code>avpriv_set_pts_info()</code> 进行设置。</li>
<li><p>b) 对于音频，检查采样率设置是否正确；对于视频，检查宽、高、宽高比。</p>
</li>
<li><p>c) 其他一些检查，不再详述。</p>
</li>
</ul>
<p><strong>AVOutputFormat-&gt;write_header()</strong></p>
<p><code>avformat_write_header()</code> 中最关键的地方就是调用了 AVOutputFormat 的 <code>write_header()</code>。</p>
<p><code>write_header()</code> 是 AVOutputFormat 中的一个函数指针，指向写文件头的函数。不同的AVOutputFormat 有不同的 <code>write_header()</code> 的实现方法。在这里我们举例子看一下 FLV 封装格式对应的 AVOutputFormat，它的定义位于 <code>libavformat\flvenc.c</code></p>
<p>从 <code>ff_flv_muxer</code> 的定义中可以看出，<code>write_header()</code> 指向的函数为 <code>flv_write_header()</code>。我们继续看一下 <code>flv_write_header()</code> 函数。<code>flv_write_header()</code> 的定义同样位于 <code>libavformat\flvenc.c</code></p>
<p>从源代码可以看出，<code>flv_write_header()</code> 完成了FLV文件头的写入工作。该函数的工作可以大体分为以下两部分：</p>
<p>（1）给 FLVContext 设置参数</p>
<p>（2）写文件头，以及相关的 Tag</p>
<p>可以参考下图中 FLV 文件头的定义比对一下上面的代码。</p>
<p><img alt="FLV Header.png" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/FLVHeader.png" data-index="34" data-src="/images/imageFFmpeg/Thor/FLVHeader.png"></p>
<h2 id="avcodec-encode-video"><a href="#avcodec-encode-video" class="headerlink" title="avcodec_encode_video()"></a>avcodec_encode_video()</h2><p>该函数用于编码一帧视频数据。<code>avcodec_encode_video2()</code> 函数的声明位于 <code>libavcodec\avcodec.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avcodec_encode_video2</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> AVFrame *frame, <span class="keyword">int</span> *got_packet_ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数每个参数的含义在注释里面已经写的很清楚了，在这里用中文简述一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avctx：编码器的AVCodecContext。</span><br><span class="line">avpkt：编码输出的AVPacket。</span><br><span class="line">frame：编码输入的AVFrame。</span><br><span class="line">got_packet_ptr：成功编码一个AVPacket的时候设置为1。</span><br></pre></td></tr></table></figure>
<p>函数返回0代表编码成功。</p>
<p>函数的调用关系如下图所示：</p>
<p><img alt="avcodec_encode_video" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thoreavcodec_encode_video.png" data-index="35" data-src="/images/imageFFmpeg/Thoreavcodec_encode_video.png"></p>
<p><code>avcodec_encode_video2()</code> 的定义位于 <code>libavcodec\utils.c</code></p>
<p>从函数的定义可以看出，<code>avcodec_encode_video2()</code> 首先调用了 <code>av_image_check_size()</code> 检查设置的宽高参数是否合理，然后调用了 AVCodec 的 <code>encode2()</code> 调用具体的解码器。</p>
<p><code>av_image_check_size()</code> 主要是要求图像宽高必须为正数，而且取值不能太大。</p>
<p>AVCodec 的 <code>encode2()</code> 是一个函数指针，指向特定编码器的编码函数</p>
<p>从 <code>ff_libx264_encoder</code> 的定义可以看出，<code>encode2()</code> 函数指向的是 <code>X264_frame()</code> 函数。</p>
<p><code>X264_frame()</code> 函数的定义位于 <code>libavcodec\libx264.c</code></p>
<h2 id="av-write-frame"><a href="#av-write-frame" class="headerlink" title="av_write_frame()"></a>av_write_frame()</h2><p><code>av_write_frame()</code> 用于输出一帧视音频数据，它的声明位于 <code>libavformat\avformat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_write_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简单解释一下它的参数的含义：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s：用于输出的AVFormatContext。</span><br><span class="line">pkt：等待输出的AVPacket。</span><br></pre></td></tr></table></figure>
<p>函数正常执行后返回值等于 0。</p>
<p><code>av_write_frame()</code> 的调用关系如下图所示：</p>
<p><img alt="av_write_frame" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_write_frame.png" data-index="36" data-src="/images/imageFFmpeg/Thor/av_write_frame.png"></p>
<p><code>av_write_frame()</code> 的定义位于 <code>libavformat\mux.c</code></p>
<p>从源代码可以看出，<code>av_write_frame()</code> 主要完成了以下几步工作：</p>
<p>（1）调用 <code>check_packet()</code> 做一些简单的检测</p>
<p>（2）调用 <code>compute_pkt_fields2()</code> 设置 AVPacket 的一些属性值</p>
<p>（3）调用 <code>write_packet()</code> 写入数据</p>
<p><code>check_packet()</code> 的功能比较简单：首先检查一下输入的 AVPacket 是否为空，如果为空，则是直接返回；然后检查一下 AVPacket 的 <code>stream_index</code>（标记了该 AVPacket 所属的 AVStream）设置是否正常，如果为负数或者大于 AVStream 的个数，则返回错误信息；最后检查 AVPacket 所属的 AVStream 是否属于 attachment stream，这个地方没见过，目前还没有研究。</p>
<p><code>compute_pkt_fields2()</code> 函数的定义位于 <code>libavformat\mux.c</code></p>
<p><code>compute_pkt_fields2()</code> 主要有两方面的功能：</p>
<ul>
<li>一方面用于计算 AVPacket 的 duration， dts 等信息；</li>
<li>另一方面用于检查 pts、dts 这些参数的合理性（例如 PTS 是否一定大于 DTS）。具体的代码还没有细看，以后有时间再进行分析。</li>
</ul>
<p><code>write_packet()</code> 函数的定义位于 <code>libavformat\mux.c</code></p>
<p><code>write_packet()</code> 函数最关键的地方就是调用了 AVOutputFormat 中写入数据的方法。如果 AVPacket 中的 flag 标记中包含 AV_PKT_FLAG_UNCODED_FRAME，就会调用 AVOutputFormat 的 <code>write_uncoded_frame()</code> 函数；如果不包含那个标记，就会调用 <code>write_packet()</code> 函数。 <code>write_packet()</code> 实际上是一个函数指针，指向特定的 AVOutputFormat 中的实现函数。例如，我们看一下 FLV 对应的 AVOutputFormat，位于 <code>libavformat\flvenc.c</code></p>
<p>从 <code>ff_flv_muxer</code> 的定义可以看出，<code>write_packet()</code> 指向的是 <code>flv_write_packet()</code> 函数。在看 <code>flv_write_packet()</code> 函数的定义之前，先回顾一下 FLV 封装格式的结构。</p>
<h2 id="av-write-trailer"><a href="#av-write-trailer" class="headerlink" title="av_write_trailer()"></a>av_write_trailer()</h2><p><code>av_write_trailer()</code> 用于输出文件尾，它的声明位于 <code>libavformat\avformat.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_write_trailer</span><span class="params">(AVFormatContext *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它只需要指定一个参数，即用于输出的 AVFormatContext。</p>
<p>函数正常执行后返回值等于 0。</p>
<p><code>av_write_trailer()</code> 的调用关系如下图所示：</p>
<p><img alt="av_write_trailer" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_write_trailer.png" data-index="37" data-src="/images/imageFFmpeg/Thor/av_write_trailer.png"></p>
<p><code>av_write_trailer()</code> 的定义位于 <code>libavformat\mux.c</code></p>
<p>从源代码可以看出 <code>av_write_trailer()</code> 主要完成了以下两步工作：</p>
<p>（1）循环调用 <code>interleave_packet()</code> 以及 <code>write_packet()</code>，将还未输出的 AVPacket 输出出来。</p>
<p>（2）调用 AVOutputFormat 的 <code>write_trailer()</code>，输出文件尾。</p>
<p>其中第一步和 <code>av_write_frame()</code> 中的步骤大致是一样的（<code>interleave_packet()</code> 这一部分在并不包含在 <code>av_write_frame()</code> 中，而是包含在 <code>av_interleaved_write_frame()</code> 中，这一部分源代码还没有分析）</p>
<p>AVOutputFormat 的 <code>write_trailer()</code> 是一个函数指针，指向特定的 AVOutputFormat 中的实现函数。我们以 FLV 对应的 AVOutputFormat 为例，看一下它的定义</p>
<p>从 FLV 对应的 AVOutputFormat 结构体的定义我们可以看出，<code>write_trailer()</code> 指向了<code>flv_write_trailer()</code> 函数。</p>
<p><code>flv_write_trailer()</code> 函数的定义位于 <code>libavformat\flvenc.c</code></p>
<p>从 <code>flv_write_trailer()</code> 的源代码可以看出该函数做了以下两步工作：</p>
<p>（1）如果视频流是 H.264，则添加包含 EOS（End Of Stream） NALU 的 Tag。</p>
<p>（2）更新 FLV 的时长信息，以及文件大小信息。</p>
<p>其中，<code>put_avc_eos_tag()</code> 函数用于添加包含 EOS NALU 的 Tag（包含结尾的一个PreviousTagSize）</p>
<p>可以参考 FLV 封装格式理解上述函数。由于前面的文章中已经描述过 FLV 封装格式，在这里不再重复叙述，在这里仅在此记录一下 AVCVIDEOPACKET 的格式，如下所示。</p>
<p><img alt="AVCVIDEOPACKET格式" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/AVCVIDEOPACKET格式.png" data-index="38" data-src="/images/imageFFmpeg/Thor/AVCVIDEOPACKET格式.png"></p>
<p>可以看出包含 EOS NALU 的 AVCVIDEOPACKET 的 AVCPacketType 为 2。在这种情况下， AVCVIDEOPACKET 的 CompositionTime 字段取 0，并且无需包含 Data 字段。</p>
<h1 id="日志输出系统"><a href="#日志输出系统" class="headerlink" title="日志输出系统"></a>日志输出系统</h1><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44243155" target="_blank" rel="noopener">日志输出系统</a></p>
</blockquote>
<h2 id="av-log"><a href="#av-log" class="headerlink" title="av_log()"></a>av_log()</h2><p>本文分析一下 FFmpeg 的日志（Log）输出系统的源代码。日志输出部分的核心函数只有一个： <code>av_log()</code>。使用 <code>av_log()</code> 在控制台输出日志的效果如下图所示。</p>
<p><img alt="av_log控制台日志输出" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_log控制台日志输出.png" data-index="39" data-src="/images/imageFFmpeg/Thor/av_log控制台日志输出.png"></p>
<p>FFmpeg 日志输出系统的函数调用结构图如图所示：</p>
<p><img alt="FFmpeg 日志输出系统的函数调用结构图" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/av_log.png" data-index="40" data-src="/images/imageFFmpeg/Thor/av_log.png"></p>
<p><code>av_log()</code> 是 FFmpeg 中输出日志的函数。随便打开一个 FFmpeg 的源代码文件，就会发现其中遍布着 <code>av_log()</code> 函数。一般情况下 FFmpeg 类库的源代码中是不允许使用 <code>printf()</code> 这种的函数的，所有的输出一律使用 <code>av_log()</code>。</p>
<p>av_log()的声明位于libavutil\log.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_log</span><span class="params">(<span class="keyword">void</span> *avcl, <span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> <span class="title">av_printf_format</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的声明有两个地方比较特殊：</p>
<p>（1）函数最后一个参数是 “…”。</p>
<p>在 C 语言中，在函数参数数量不确定的情况下使用 “…” 来代表参数。例如 <code>printf()</code> 的原型定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>（2）它的声明后面有一个 <code>av_printf_format(3, 4)</code>。有关这个地方的左右还没有深入研究，网上资料中说它的作用是按照 <code>printf()</code> 的格式检查 <code>av_log()</code> 的格式。</p>
<p>av_log()每个字段的含义如下：</p>
<ul>
<li>avcl：指定一个包含 AVClass 的结构体。</li>
<li>level：log 的级别</li>
<li>fmt：和 <code>printf()</code> 一样。</li>
</ul>
<p>由此可见，<code>av_log()</code> 和 <code>printf()</code> 的不同主要在于前面多了两个参数。其中第一个参数指定该 log 所属的结构体，例如 AVFormatContext、AVCodecContext 等等。第二个参数指定 log 的级别，源代码中定义了如下几个级别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_QUIET    -8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_PANIC     0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_FATAL     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_ERROR    16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_WARNING  24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_INFO     32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_VERBOSE  40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_LOG_DEBUG    48</span></span><br></pre></td></tr></table></figure>
<p>从定义中可以看出来，随着严重程度逐渐下降，一共包含如下级别：</p>
<ul>
<li>AV_LOG_PANIC，</li>
<li>AV_LOG_FATAL，</li>
<li>AV_LOG_ERROR，</li>
<li>AV_LOG_WARNING，</li>
<li>AV_LOG_INFO，</li>
<li>AV_LOG_VERBOSE，</li>
<li>AV_LOG_DEBUG。</li>
</ul>
<p>每个级别定义的数值代表了严重程度，数值越小代表越严重。默认的级别是 AV_LOG_INFO。此外，还有一个级别不输出任何信息，即 AV_LOG_QUIET。</p>
<p>当前系统存在着一个 “Log级别”。所有严重程度高于该级别的 Log 信息都会输出出来。例如当前的 Log 级别是 AV_LOG_WARNING，则会输出 AV_LOG_PANIC，AV_LOG_FATAL，AV_LOG_ERROR，AV_LOG_WARNING 级别的信息，而不会输出 AV_LOG_INFO 级别的信息。可以通过 <code>av_log_get_level()</code> 获得当前 Log 的级别，通过另一个函数 <code>av_log_set_level()</code> 设置当前的 Log 级别。</p>
<p>可以通过 <code>av_log_set_level()</code> 设置当前 Log 的级别。</p>
<h1 id="接头体成员管理系统"><a href="#接头体成员管理系统" class="headerlink" title="接头体成员管理系统"></a>接头体成员管理系统</h1><h2 id="AVClass"><a href="#AVClass" class="headerlink" title="AVClass"></a>AVClass</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44268323" target="_blank" rel="noopener">FFmpeg源代码简单分析：结构体成员管理系统-AVClass</a></p>
</blockquote>
<p>TODO</p>
<h2 id="AVOption"><a href="#AVOption" class="headerlink" title="AVOption"></a>AVOption</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44279329" target="_blank" rel="noopener">FFmpeg源代码简单分析：结构体成员管理系统-AVOption</a></p>
</blockquote>
<p>TODO</p>
<h1 id="libswscale"><a href="#libswscale" class="headerlink" title="libswscale"></a>libswscale</h1><h2 id="sws-getContext"><a href="#sws-getContext" class="headerlink" title="sws_getContext()"></a>sws_getContext()</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44305697" target="_blank" rel="noopener">FFmpeg源代码简单分析：libswscale的sws_getContext()</a></p>
</blockquote>
<p>TODO</p>
<h2 id="sws-scale"><a href="#sws-scale" class="headerlink" title="sws_scale()"></a>sws_scale()</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44346687" target="_blank" rel="noopener">FFmpeg源代码简单分析：libswscale的sws_scale()</a></p>
</blockquote>
<p>TODO</p>
<h1 id="libavdevice"><a href="#libavdevice" class="headerlink" title="libavdevice"></a>libavdevice</h1><h2 id="avdevice-register-all"><a href="#avdevice-register-all" class="headerlink" title="avdevice_register_all()"></a>avdevice_register_all()</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/41211121" target="_blank" rel="noopener">FFmpeg源代码简单分析：libavdevice的avdevice_register_all()</a></p>
</blockquote>
<h2 id="gdigrab"><a href="#gdigrab" class="headerlink" title="gdigrab"></a>gdigrab</h2><blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44597955" target="_blank" rel="noopener">FFmpeg源代码简单分析：libavdevice的gdigrab</a></p>
</blockquote>
<p><img alt class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/" data-index="41" data-src="/images/imageFFmpeg/Thor/"></p>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/FFmpeg/" rel="tag"># FFmpeg</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>

    
    <nav id="gobottom" class="pagination">
        
        <a class="prev-post" title="WebRTC开源src" href="/2019-05-27/reference/webrtc/webrtc-opensrc/">
            ← WebRTC开源src
        </a>
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="FFmpeg 源代码结构（编解码解析）" href="/2019-05-25/reference/FFmpeg/FFmpeg源代码结构note/">
            FFmpeg 源代码结构（编解码解析） →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#架构图"><span class="toc-text">架构图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FFMPEG-SDL的视频播放器"><span class="toc-text">FFMPEG+SDL的视频播放器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FFMPEG的视频编码器（YUV编码为H-264）"><span class="toc-text">FFMPEG的视频编码器（YUV编码为H.264）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FFmpeg编码视频的流程图"><span class="toc-text">FFmpeg编码视频的流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#“纯净”的基于FFmpeg的视频编码器"><span class="toc-text">“纯净”的基于FFmpeg的视频编码器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解码框架图"><span class="toc-text">解码框架图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码框架图"><span class="toc-text">编码框架图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通用函数解析"><span class="toc-text">通用函数解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#av-register-all"><span class="toc-text">av_register_all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存的分配和释放（av-malloc-、av-free-等）"><span class="toc-text">内存的分配和释放（av_malloc()、av_free()等）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于size-t"><span class="toc-text">关于size_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要内存对齐？"><span class="toc-text">为什么要内存对齐？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见结构体的初始化和销毁（AVFormatContext，AVFrame等）"><span class="toc-text">常见结构体的初始化和销毁（AVFormatContext，AVFrame等）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#avformat-alloc-context"><span class="toc-text">avformat_alloc_context()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#avio-alloc-context"><span class="toc-text">avio_alloc_context()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#avformat-new-stream"><span class="toc-text">avformat_new_stream()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#avcodec-alloc-context3"><span class="toc-text">avcodec_alloc_context3()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#av-frame-alloc"><span class="toc-text">av_frame_alloc()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#avpicture-fill"><span class="toc-text">avpicture_fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#av-image-fill-arrays"><span class="toc-text">av_image_fill_arrays()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#av-init-packet"><span class="toc-text">av_init_packet()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#av-new-packet"><span class="toc-text">av_new_packet()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avio-open2"><span class="toc-text">avio_open2()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#av-find-decoder-和-av-find-encoder"><span class="toc-text">av_find_decoder() 和 av_find_encoder()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avcodec-open2"><span class="toc-text">avcodec_open2()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检查输入参数是否符合编码器要求"><span class="toc-text">检查输入参数是否符合编码器要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVCodec-gt-init"><span class="toc-text">AVCodec-&gt;init()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avcodec-close"><span class="toc-text">avcodec_close()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解码"><span class="toc-text">解码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图解-FFMPEG-打开媒体的函数-avformat-open-input"><span class="toc-text">图解 FFMPEG 打开媒体的函数 avformat_open_input</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avformat-open-input"><span class="toc-text">avformat_open_input()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init-input"><span class="toc-text">init_input()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avformat-find-stream-info"><span class="toc-text">avformat_find_stream_info()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#av-read-frame"><span class="toc-text">av_read_frame()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Audio-Tag-Data"><span class="toc-text">Audio Tag Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Video-Tag-Data"><span class="toc-text">Video Tag Data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avcodec-decode-video2"><span class="toc-text">avcodec_decode_video2()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avformat-close-input"><span class="toc-text">avformat_close_input()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编码"><span class="toc-text">编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#avformat-alloc-output-context2"><span class="toc-text">avformat_alloc_output_context2()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avformat-write-header"><span class="toc-text">avformat_write_header()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#avcodec-encode-video"><span class="toc-text">avcodec_encode_video()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#av-write-frame"><span class="toc-text">av_write_frame()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#av-write-trailer"><span class="toc-text">av_write_trailer()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#日志输出系统"><span class="toc-text">日志输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#av-log"><span class="toc-text">av_log()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接头体成员管理系统"><span class="toc-text">接头体成员管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AVClass"><span class="toc-text">AVClass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVOption"><span class="toc-text">AVOption</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#libswscale"><span class="toc-text">libswscale</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sws-getContext"><span class="toc-text">sws_getContext()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sws-scale"><span class="toc-text">sws_scale()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#libavdevice"><span class="toc-text">libavdevice</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#avdevice-register-all"><span class="toc-text">avdevice_register_all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gdigrab"><span class="toc-text">gdigrab</span></a></li></ol></li></ol>
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(/images/favicon-32x32-next.png)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; Pastor Dean &mdash;</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2020-01-16/thinking/Thinking modelBiological thinking Biological thinking looking at the business world from an evolutionary perspective/">Thinking modelBiological thinking Biological thinking: looking at the business world from an evolutionary perspective</a>
      </li>
      
      
      
      <li>
        <a href="/2020-01-13/thinking/Modern Darwin Integrated Model  Biological Thinking Mode Opening God Perspective/">Modern Darwin Integrated Model Biological Thinking Mode Opening God is Perspective</a>
      </li>
      
      
      
      <li>
        <a href="/2020-01-11/thinking/Metacognition Changing the stubborn thinking of the brain/">Metacognition Changing the stubborn thinking of the brain</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(/images/favicon-32x32-next.png)">
    <header class="read-next-card-header tagcloud-card">
        <h3 class="read-next-card-header-title">Categories</h3>
    </header>
    <div class="read-next-card-content">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Biological-Thinking/">Biological Thinking</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cognitive-Neuroscience/">Cognitive Neuroscience</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DeepLearning/">DeepLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FFmpeg/">FFmpeg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MacOS/">MacOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MachineLearning/">MachineLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NLP/">NLP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PM/">PM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ubuntu/">Ubuntu</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebRTC/">WebRTC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/deeplearn/">deeplearn</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/machineLearning/">machineLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文摘/">文摘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构师/">架构师</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/知识图谱/">知识图谱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/职业规划/">职业规划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/职业规划/个人提升/">个人提升</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机相关技术资料整理/">计算机相关技术资料整理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/认知升级/">认知升级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/财务自由/">财务自由</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/财富自由/">财富自由</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(/images/favicon-32x32-next.png)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/AI/" style="font-size: 14px;">AI</a> <a href="/tags/Android/" style="font-size: 14px;">Android</a> <a href="/tags/Biological/" style="font-size: 17.75px;">Biological</a> <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/Business/" style="font-size: 16.5px;">Business</a> <a href="/tags/Cognitive/" style="font-size: 17.75px;">Cognitive</a> <a href="/tags/DeepLearning/" style="font-size: 15.25px;">DeepLearning</a> <a href="/tags/Docker/" style="font-size: 14px;">Docker</a> <a href="/tags/FFmpeg/" style="font-size: 21.5px;">FFmpeg</a> <a href="/tags/FastCGI/" style="font-size: 14px;">FastCGI</a> <a href="/tags/IP划分/" style="font-size: 14px;">IP划分</a> <a href="/tags/IP地址/" style="font-size: 14px;">IP地址</a> <a href="/tags/Knowledge-Graph/" style="font-size: 16.5px;">Knowledge Graph</a> <a href="/tags/Linux-Shell/" style="font-size: 14px;">Linux Shell</a> <a href="/tags/MacOS/" style="font-size: 15.25px;">MacOS</a> <a href="/tags/Neuroscience/" style="font-size: 17.75px;">Neuroscience</a> <a href="/tags/RPC/" style="font-size: 14px;">RPC</a> <a href="/tags/Thinking/" style="font-size: 17.75px;">Thinking</a> <a href="/tags/Tutorial/" style="font-size: 20.25px;">Tutorial</a> <a href="/tags/WebRTC/" style="font-size: 21.5px;">WebRTC</a> <a href="/tags/WebSocket/" style="font-size: 14px;">WebSocket</a> <a href="/tags/algorithm/" style="font-size: 15.25px;">algorithm</a> <a href="/tags/config/" style="font-size: 14px;">config</a> <a href="/tags/decisionTree/" style="font-size: 14px;">decisionTree</a> <a href="/tags/git/" style="font-size: 17.75px;">git</a> <a href="/tags/google-adsense/" style="font-size: 14px;">google adsense</a> <a href="/tags/hexo/" style="font-size: 17.75px;">hexo</a> <a href="/tags/http/" style="font-size: 17.75px;">http</a> <a href="/tags/knn/" style="font-size: 14px;">knn</a> <a href="/tags/lighttpd/" style="font-size: 15.25px;">lighttpd</a> <a href="/tags/mxnet/" style="font-size: 14px;">mxnet</a> <a href="/tags/mysql/" style="font-size: 22.75px;">mysql</a> <a href="/tags/nlp/" style="font-size: 24px;">nlp</a> <a href="/tags/nodejs/" style="font-size: 14px;">nodejs</a> <a href="/tags/openvpn/" style="font-size: 14px;">openvpn</a> <a href="/tags/other/" style="font-size: 15.25px;">other</a> <a href="/tags/paddle/" style="font-size: 14px;">paddle</a> <a href="/tags/planning/" style="font-size: 20.25px;">planning</a> <a href="/tags/pracitce/" style="font-size: 15.25px;">pracitce</a> <a href="/tags/rich/" style="font-size: 14px;">rich</a> <a href="/tags/shell/" style="font-size: 14px;">shell</a> <a href="/tags/svn/" style="font-size: 14px;">svn</a> <a href="/tags/ubuntu/" style="font-size: 14px;">ubuntu</a> <a href="/tags/vim/" style="font-size: 16.5px;">vim</a> <a href="/tags/webpack/" style="font-size: 14px;">webpack</a> <a href="/tags/webrtc/" style="font-size: 19px;">webrtc</a> <a href="/tags/个人发展/" style="font-size: 14px;">个人发展</a> <a href="/tags/互联网实事/" style="font-size: 14px;">互联网实事</a> <a href="/tags/外链/" style="font-size: 14px;">外链</a> <a href="/tags/提升个人思维/" style="font-size: 14px;">提升个人思维</a> <a href="/tags/文摘/" style="font-size: 15.25px;">文摘</a> <a href="/tags/斜杠青年/" style="font-size: 14px;">斜杠青年</a> <a href="/tags/机器学习/" style="font-size: 16.5px;">机器学习</a> <a href="/tags/架构师/" style="font-size: 14px;">架构师</a> <a href="/tags/测试工具/" style="font-size: 14px;">测试工具</a> <a href="/tags/睡后成长/" style="font-size: 14px;">睡后成长</a> <a href="/tags/睡后收入/" style="font-size: 14px;">睡后收入</a> <a href="/tags/税后收入/" style="font-size: 14px;">税后收入</a> <a href="/tags/笔记/" style="font-size: 14px;">笔记</a> <a href="/tags/自然语言处理/" style="font-size: 24px;">自然语言处理</a> <a href="/tags/视频流/" style="font-size: 15.25px;">视频流</a> <a href="/tags/计算机相关技术资料整理/" style="font-size: 14px;">计算机相关技术资料整理</a> <a href="/tags/认知升级/" style="font-size: 14px;">认知升级</a> <a href="/tags/限速/" style="font-size: 14px;">限速</a> <a href="/tags/面试/" style="font-size: 14px;">面试</a> <a href="/tags/项目管理/" style="font-size: 14px;">项目管理</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="/images/favicon-16x16-next.png" alt="Pastor Dean">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="Pastor Dean">Pastor Dean &copy; 2020</a>
			
				
			        <span hidden="true" id="/2019-05-27/reference/FFmpeg/FFmpeg框架函数分析/" class="leancloud-visitors" data-flag-title="FFmpeg框架详解">
			            <span>阅读量 </span>
			            <span class="leancloud-visitors-count">0</span>
			        </span>
	    		
    		
		</div>
		<nav class="site-footer-nav">
			
			<a href="https://hexo.io" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>


<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>



<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>




<script id="valineScript" src="//unpkg.com/valine/dist/Valine.min.js" async></script>
<script>
    document.getElementById('valineScript').addEventListener("load", function() {
        new Valine({
            el: '#comment' ,
            verify: false,
            notify: false,
            appId: '',
            appKey: '',
            placeholder: 'Just go go',
            pageSize: 10,
            avatar: 'mm',
            visitor: true
        })
    });
</script>





</body>
</html>
