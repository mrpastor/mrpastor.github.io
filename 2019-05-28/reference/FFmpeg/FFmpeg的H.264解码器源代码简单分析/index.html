<!DOCTYPE html>
<html lang="en">







<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">

	<title>FFmpeg的H.264解码器源代码简单分析 | Pastor Dean</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="pastor">
	<meta name="description" content>

	
	<meta name="keywords" content>
	

	
	<link rel="shortcut icon" href="/images/favicon-16x16-next.png">
	<link rel="apple-touch-icon" href="/images/favicon-16x16-next.png">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="Pastor Dean">
	<meta property="og:type" content="article">
	<meta property="og:title" content="FFmpeg的H.264解码器源代码简单分析 | Pastor Dean">
	<meta property="og:description" content>
	<meta property="og:url" content="https://mrpastor.github.io/2019-05-28/reference/FFmpeg/FFmpeg的H.264解码器源代码简单分析/">

	
	<meta property="article:published_time" content="2019-05-28T10:05:00+08:00"> 
	<meta property="article:author" content="pastor">
	<meta property="article:published_first" content="Pastor Dean, /2019-05-28/reference/FFmpeg/FFmpeg的H.264解码器源代码简单分析/">
	

	
	
	<link rel="stylesheet" href="/css/allinonecss.min.css">

	
	
	
</head>
<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                
                <a class="site-nav-logo" href="/" title="Pastor Dean">
                    <img src="/images/favicon-32x32-next.png" alt="Pastor Dean">
                </a>
                
                
            </li>
            
            
            <li>
                <a href="/ || home" title="home">home</a>
            </li>
            
            <li>
                <a href="/categories/ || th" title="categories">categories</a>
            </li>
            
            <li>
                <a href="/archives/ || archive" title="archives">archives</a>
            </li>
            
            <li>
                <a href="/tools/ || tools" title="tools">tools</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    
    <a class="social-link" title="github" href="https://github.com/mrpastor" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    <a class="social-link" title="facebook" href="https://facebook" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

    </a>
    
    
    <a class="social-link" title="twitter" href="https://twitter.com" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

    </a>
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2019-05-28T02:14:50.000Z">
                    2019-05-28
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/FFmpeg/">FFmpeg</a>&nbsp;&nbsp;
                
                
            </div>
            <h1 class="post-full-title">FFmpeg的H.264解码器源代码简单分析</h1>
        </header>
        <div class="post-full no-image">
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <blockquote>
<p>文章参考汇总至<a href="https://blog.csdn.net/leixiaohua1020/article/details/45536607" target="_blank" rel="noopener">雷神笔记</a></p>
</blockquote>
<h1 id="编码-x264"><a href="#编码-x264" class="headerlink" title="编码 - x264"></a>编码 - x264</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近正在研究H.264和HEVC的编码方式，因此分析了一下最常见的H.264编码器——x264的源代码。本文简单梳理一下它的结构。X264的源代码量比较大而且涉及到很多的算法，目前还有很多不懂的地方，因此也不能保证分析的完全正确。目前打算先把已经理解的部分整理出来以作备忘。</p>
<h3 id="函数调用关系图"><a href="#函数调用关系图" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><a id="more"></a>
<p><img alt="X264的函数调用关系图" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/X264的函数调用关系图.png" data-index="0" data-src="/images/imageFFmpeg/Thor/X264的函数调用关系图.png"></p>
<p>下面解释一下图中关键标记的含义。</p>
<h4 id="函数背景色"><a href="#函数背景色" class="headerlink" title="函数背景色"></a>函数背景色</h4><p>函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用：</p>
<ul>
<li><strong>白色背景的函数</strong>：不加区分的普通内部函数。</li>
<li><strong>浅红背景的函数</strong>：libx264类库的接口函数（API）。</li>
<li><strong>粉红色背景函数</strong>：滤波函数（Filter）。用于环路滤波，半像素插值，SSIM/PSNR的计算。</li>
<li><strong>黄色背景函数</strong>：分析函数（Analysis）。用于帧内预测模式的判断，或者帧间预测模式的判断。</li>
<li><strong>绿色背景的函数</strong>：宏块编码函数（Encode）。通过对残差的DCT变换、量化等方式对宏块进行编码。</li>
<li><strong>紫色背景的函数</strong>：熵编码函数（Entropy Coding）。对宏块编码后的数据进行CABAC或者CAVLC熵编码。</li>
<li><p><strong>蓝色背景函数</strong>：汇编函数（Assembly）。做过汇编优化的函数。图中主要画出了这些函数的C语言版本，此外这些函数还包含MMX版本、SSE版本、NEON版本等。</p>
</li>
<li><p><strong>浅蓝色背景函数</strong>：码率控制函数（Rate Control）。对码率进行控制的函数。具体的方法包括了ABR、CBR、CRF等。</p>
</li>
</ul>
<h4 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h4><p>整个关系图可以分为以下几个区域：</p>
<ul>
<li><strong>最左边区域</strong>——x264命令行程序函数区域。</li>
<li><strong>左边中间区域</strong>——libx264内部函数区域。</li>
<li><strong>右上方粉红色区域</strong>——滤波模块。其中包括了环路滤波，半像素插值，SSIM/PSNR计算。</li>
<li><strong>右上方黄色区域</strong>——分析模块。其中包含了帧内预测模式分析以及帧间运动估计等。</li>
<li><strong>右中间绿色区域</strong>——宏块编码模块。其中包含了针对编码帧的DCT变换，量化，Hadamard变换等；以及针对重建帧的DCT反变换，反量化，Hadamard反变换等。</li>
<li><strong>右下方紫色区域</strong>——熵编码模块。其中包含了CABAC或者CAVLC熵编码。</li>
</ul>
<h4 id="箭头线"><a href="#箭头线" class="headerlink" title="箭头线"></a>箭头线</h4><p>箭头线标志了函数的调用关系：</p>
<ul>
<li><strong>黑色箭头线</strong>：不加区别的调用关系。</li>
<li><strong>粉红色的箭头线</strong>：滤波函数（Filter）之间的调用关系。</li>
<li><strong>黄色箭头线</strong>：分析函数（Analysis）之间的调用关系。</li>
<li><strong>绿色箭头线</strong>：宏块编码函数（Encode）之间的调用关系。</li>
<li><strong>紫色箭头线</strong>：熵编码函数（Entropy Coding）之间的调用关系。</li>
</ul>
<h4 id="函数所在的文件"><a href="#函数所在的文件" class="headerlink" title="函数所在的文件"></a>函数所在的文件</h4><p>每个函数标识了它所在的文件路径。</p>
<h3 id="几个关键的部分"><a href="#几个关键的部分" class="headerlink" title="几个关键的部分"></a>几个关键的部分</h3><p>下文简单记录图中几个关键的部分。</p>
<h4 id="x264命令行程序"><a href="#x264命令行程序" class="headerlink" title="x264命令行程序"></a>x264命令行程序</h4><p>x264命令行程序指的是x264项目提供的控制台程序。通过这个程序可以调用libx264编码YUV为H.264码流。该程序的入口函数为 <code>main()</code>。<code>main()</code> 函数首先调用 <code>parse()</code> 解析输入的参数，然后调用 <code>encode()</code> 编码YUV数据。</p>
<font style="color:red;"><strong>parse()</strong></font>首先调用 <code>x264_param_default()</code> 为保存参数的 <code>x264_param_t</code> 结构体赋默认值；然后在一个大循环中通过 <code>getopt_long()</code> 解析通过命令行传递来的存储在 <code>argv[]</code> 中的参数，并作相应的设置工作；最后调用 <code>select_input()</code> 和 <code>select_output()</code> 完成输入文件格式（yuv，y4m等）和输出文件格式（裸流，mp4，mkv，FLV等）的设置。<br><br><font style="color:red;"><strong>encode()</strong></font>首先调用 <code>x264_encoder_open()</code> 打开编码器；接着在一个循环中反复调用 <code>encode_frame()</code> 一帧一帧地进行编码；最后在编码完成后调用 <code>x264_encoder_close()</code> 关闭编码器。<br><br><font style="color:red;"><strong>encode_frame()</strong></font>则调用 <code>x264_encoder_encode()</code> 将存储YUV数据的 <code>x264_picture_t</code> 编码为存储H.264数据的 <code>x264_nal_t</code>。<br><br>#### <font style="color:#ff6600;">libx264类库的接口</font>

<p>在一个x264编码流程中，至少需要调用如下API函数（参考文章《<a href="http://blog.csdn.net/leixiaohua1020/article/details/42078645" target="_blank" rel="noopener">最简单的视频编码器：基于libx264（编码YUV为H.264）</a>》）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x264_param_default() 	<span class="comment">// 设置参数集结构体x264_param_t的缺省值。</span></span><br><span class="line">x264_picture_alloc() 	<span class="comment">// 为图像结构体x264_picture_t分配内存。</span></span><br><span class="line">x264_encoder_open() 	<span class="comment">// 打开编码器。</span></span><br><span class="line">x264_encoder_encode()	<span class="comment">// 编码一帧图像。</span></span><br><span class="line">x264_encoder_close()	<span class="comment">// 关闭编码器。</span></span><br><span class="line">x264_picture_clean()	<span class="comment">// 释放x264_picture_alloc()申请的资源。</span></span><br></pre></td></tr></table></figure>
<h4 id="libx264主干函数"><a href="#libx264主干函数" class="headerlink" title="libx264主干函数"></a>libx264主干函数</h4><p>libx264主干函数指的是编码API之后，<code>x264_slice_write()</code> 之前的函数。这一部分函数较多，暂时不详细分析，仅仅举几个例子列一下它们的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x264_encoder_open() 		<span class="comment">// 调用了下面的函数：</span></span><br><span class="line">x264_validate_parameters()	<span class="comment">// 检查输入参数（例如输入图像的宽高是否为正数）。</span></span><br><span class="line">x264_predict_16x16_init()	<span class="comment">// 初始化Intra16x16帧内预测汇编函数。</span></span><br><span class="line">x264_predict_4x4_init()		<span class="comment">// 初始化Intra4x4帧内预测汇编函数。</span></span><br><span class="line">x264_pixel_init()			<span class="comment">// 初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。</span></span><br><span class="line">x264_dct_init()				<span class="comment">// 初始化DCT变换和DCT反变换相关的汇编函数。</span></span><br><span class="line">x264_mc_init() 				<span class="comment">// 初始化运动补偿相关的汇编函数。</span></span><br><span class="line">x264_quant_init()			<span class="comment">// 初始化量化和反量化相关的汇编函数。</span></span><br><span class="line">x264_deblock_init()			<span class="comment">// 初始化去块效应滤波器相关的汇编函数。</span></span><br><span class="line">x264_lookahead_init()		<span class="comment">// 初始化Lookahead相关的变量。</span></span><br><span class="line">x264_ratecontrol_new()		<span class="comment">// 初始化码率控制模块。</span></span><br></pre></td></tr></table></figure>
<p><code>x264_encoder_headers()</code> 调用了下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x264_sps_write()			<span class="comment">// 输出SPS</span></span><br><span class="line">x264_pps_write()			<span class="comment">// 输出PPS</span></span><br><span class="line">x264_sei_version_write()	<span class="comment">// 输出SEI</span></span><br></pre></td></tr></table></figure>
<p>x264_encoder_encode()调用了下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x264_frame_pop_unused()	<span class="comment">// 获取1个x264_frame_t类型结构体fenc。如果frames.unused[]队列不为空，就调用x264_frame_pop()从unused[]队列取1个现成的；否则就调用x264_frame_new()创建一个新的。</span></span><br><span class="line">x264_frame_copy_picture()	<span class="comment">// 将输入的图像数据拷贝至fenc。</span></span><br><span class="line">x264_lookahead_put_frame()	<span class="comment">// 将fenc放入lookahead.next.list[]队列，等待确定帧类型。</span></span><br><span class="line">x264_lookahead_get_frames()	<span class="comment">// 通过lookahead分析帧类型。该函数调用了x264_slicetype_decide()，x264_slicetype_analyse()和x264_slicetype_frame_cost()等函数。经过一些列分析之后，最终确定了帧类型信息，并且将帧放入frames.current[]队列。</span></span><br><span class="line">x264_frame_shift()	<span class="comment">// 从frames.current[]队列取出一帧用于编码。</span></span><br><span class="line">x264_reference_update() <span class="comment">// 更新参考帧列表。</span></span><br><span class="line">x264_reference_reset() <span class="comment">// 如果为IDR帧，调用该函数清空参考帧列表。</span></span><br><span class="line">x264_reference_hierarchy_reset() <span class="comment">// 如果是I（非IDR帧）、P帧、B帧（可做为参考帧），调用该函数（还没研究）。</span></span><br><span class="line">x264_reference_build_list() <span class="comment">// 创建参考帧列表list0和list1。</span></span><br><span class="line">x264_ratecontrol_start() <span class="comment">// 开启码率控制。</span></span><br><span class="line">x264_slice_init() <span class="comment">// 创建 Slice Header。</span></span><br><span class="line">x264_slices_write() <span class="comment">// 编码数据（最关键的步骤）。其中调用了x264_slice_write()完成了编码的工作（注意“x264_slices_write()”和“x264_slice_write()”名字差了一个“s”）。</span></span><br><span class="line">x264_encoder_frame_end() <span class="comment">// 编码结束后做一些后续处理，例如释放一些中间变量以及打印输出一些统计信息。其中调用了x264_frame_push_unused()将fenc重新放回frames.unused[]队列，并且调用x264_ratecontrol_end()关闭码率控制。</span></span><br></pre></td></tr></table></figure>
<h4 id="x264-slice-write"><a href="#x264-slice-write" class="headerlink" title="x264_slice_write()"></a>x264_slice_write()</h4><p><code>x264_slice_write()</code> 用于编码 Slice。该函数中包含了一个很长的 <code>for()</code> 循环。该循环每执行一遍编码一个宏块。<code>x264_slice_write()</code> 中以下几个函数比较重要：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x264_nal_start() 	<span class="comment">// 开始写一个NALU。</span></span><br><span class="line">x264_macroblock_thread_init() <span class="comment">// 初始化存储宏块的重建数据缓存fdec_buf[]和编码数据缓存fenc_buf[]。</span></span><br><span class="line">x264_slice_header_write() 	<span class="comment">// 输出 Slice Header。</span></span><br><span class="line">x264_fdec_filter_row() 		<span class="comment">// 滤波模块。该模块包含了环路滤波，半像素插值，SSIM/PSNR的计算。</span></span><br><span class="line">x264_macroblock_cache_load() 	<span class="comment">// 将要编码的宏块的周围的宏块的信息读进来。</span></span><br><span class="line">x264_macroblock_analyse()		<span class="comment">// 分析模块。该模块包含了帧内预测模式分析以及帧间运动估计等。</span></span><br><span class="line">x264_macroblock_encode() <span class="comment">// 宏块编码模块。该模块通过对残差的DCT变换、量化等方式对宏块进行编码。</span></span><br><span class="line">x264_macroblock_write_cabac() <span class="comment">// CABAC熵编码模块。</span></span><br><span class="line">x264_macroblock_write_cavlc() <span class="comment">// CAVLC熵编码模块。</span></span><br><span class="line">x264_macroblock_cache_save() <span class="comment">// 保存当前宏块的信息。</span></span><br><span class="line">x264_ratecontrol_mb() <span class="comment">// 码率控制。</span></span><br><span class="line">x264_nal_end() <span class="comment">// 结束写一个NALU。</span></span><br></pre></td></tr></table></figure>
<h4 id="滤波模块"><a href="#滤波模块" class="headerlink" title="滤波模块"></a><font style="color:#ffcccc;">滤波模块</font></h4><p>滤波模块对应的函数是 <code>x264_fdec_filter_row()</code>。该函数完成了环路滤波，半像素插值，<code>SSIM/PSNR</code> 的计算的功能。该函数调用了以下及个比较重要的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x264_frame_deblock_row()	<span class="comment">// 去块效应滤波器。</span></span><br><span class="line">x264_frame_filter()			<span class="comment">// 半像素插值。</span></span><br><span class="line">x264_pixel_ssd_wxh()		<span class="comment">// PSNR计算。</span></span><br><span class="line">x264_pixel_ssim_wxh()		<span class="comment">// SSIM计算。</span></span><br></pre></td></tr></table></figure>
<h4 id="分析模块"><a href="#分析模块" class="headerlink" title="分析模块"></a><font style="color:#ffcc33;">分析模块</font></h4><p>分析模块对应的函数是 <code>x264_macroblock_analyse()</code>。该函数包含了帧内预测模式分析以及帧间运动估计等。该函数调用了以下比较重要的函数（只列举了几个有代表性的函数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x264_mb_analyse_init()			<span class="comment">// Analysis模块初始化。</span></span><br><span class="line">x264_mb_analyse_intra()			<span class="comment">// I 宏块帧内预测模式分析。</span></span><br><span class="line">x264_macroblock_probe_pskip()	<span class="comment">// 分析是否是skip模式。</span></span><br><span class="line">x264_mb_analyse_inter_p16x16()	<span class="comment">// P16x16宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_p8x8()	<span class="comment">// P8x8宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_p16x8()	<span class="comment">// P16x8宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_b16x16()	<span class="comment">// B16x16宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_b8x8()	<span class="comment">// B8x8宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_b16x8()	<span class="comment">// B16x8宏块帧间预测模式分析。</span></span><br></pre></td></tr></table></figure>
<h4 id="宏块编码模块"><a href="#宏块编码模块" class="headerlink" title="宏块编码模块"></a><font style="color:#33cc00;">宏块编码模块</font></h4><p>宏块编码模块对应的函数是 <code>x264_macroblock_encode()</code>。该模块通过对残差的 DCT 变换、量化等方式对宏块进行编码。对于 <code>Intra16x16</code> 宏块，调用 <code>x264_mb_encode_i16x16()</code> 进行编码，对于 <code>Intra4x4</code>，调用 <code>x264_mb_encode_i4x4()</code> 进行编码。对于Inter类型的宏块则直接在函数体里面编码。</p>
<h4 id="熵编码模块"><a href="#熵编码模块" class="headerlink" title="熵编码模块"></a><font style="color:#cc33cc;">熵编码模块</font></h4><p>CABAC 熵编码对应的函数是 <code>x264_macroblock_write_cabac()</code>。CAVLC 熵编码对应的函数是 <code>x264_macroblock_write_cavlc()</code>。<code>x264_macroblock_write_cavlc()</code> 调用了以下几个比较重要的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x264_cavlc_mb_header_i()		<span class="comment">// 写入I宏块MB Header数据。包含帧内预测模式等。</span></span><br><span class="line">x264_cavlc_mb_header_p()		<span class="comment">// 写入P宏块MB Header数据。包含MVD、参考帧序号等。</span></span><br><span class="line">x264_cavlc_mb_header_b()		<span class="comment">// 写入B宏块MB Header数据。包含MVD、参考帧序号等。</span></span><br><span class="line">x264_cavlc_qp_delta()			<span class="comment">// 写入QP。</span></span><br><span class="line">x264_cavlc_block_residual()		<span class="comment">// 写入残差数据。</span></span><br></pre></td></tr></table></figure>
<h4 id="码率控制模块"><a href="#码率控制模块" class="headerlink" title="码率控制模块"></a><font style="color:#66cccc;">码率控制模块</font></h4><p>码率控制模块函数分布在x264源代码不同的地方，包含了以下几个比较重要的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x264_encoder_open() 	中的 x264_ratecontrol_new()		<span class="comment">// 创建码率控制。</span></span><br><span class="line">x264_encoder_encode() 	中的 x264_ratecontrol_start()		<span class="comment">// 开始码率控制。</span></span><br><span class="line">x264_slice_write()		中的 x264_ratecontrol_mb()		<span class="comment">// 码率控制算法。</span></span><br><span class="line">x264_encoder_encode()	中的 x264_ratecontrol_end()		<span class="comment">// 结束码率控制。</span></span><br><span class="line">x264_encoder_close()	中的 x264_ratecontrol_summary()	<span class="comment">// 码率控制信息。</span></span><br><span class="line">x264_encoder_close()	中的 x264_ratecontrol_delete()	<span class="comment">// 释放码率控制。</span></span><br></pre></td></tr></table></figure>
<h2 id="x264命令行工具"><a href="#x264命令行工具" class="headerlink" title="x264命令行工具"></a>x264命令行工具</h2><p>该命令行工具可以调用 libx264 将 YUV 格式像素数据编码为 H.264 码流。</p>
<h3 id="函数调用关系图-1"><a href="#函数调用关系图-1" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="X264命令行工具的源代码的调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/X264命令行工具的源代码的调用关系.png" data-index="1" data-src="/images/imageFFmpeg/Thor/X264命令行工具的源代码的调用关系.png"></p>
<p>从图中可以看出，X264命令行工具调用了libx264的几个API完成了H.264编码工作。使用libx264的API进行编码可以参考《<a href="http://blog.csdn.net/leixiaohua1020/article/details/42078645" target="_blank" rel="noopener">最简单的视频编码器：基于libx264（编码YUV为H.264）</a>》，这个流程中最关键的API包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x264_param_default()	<span class="comment">// 设置参数集结构体x264_param_t的缺省值。</span></span><br><span class="line">x264_encoder_open()		<span class="comment">// 打开编码器。</span></span><br><span class="line">x264_encoder_headers()	<span class="comment">// 输出SPS，PPS，SEI等信息。</span></span><br><span class="line">x264_encoder_encode()	<span class="comment">// 编码输出一帧图像。</span></span><br><span class="line">x264_encoder_close()	<span class="comment">// 关闭编码器。</span></span><br></pre></td></tr></table></figure>
<p>在X264命令行工具中，<code>main()</code> 首先调用 <code>parse()</code> 解析输入的命令行参数，然后调用 <code>encode()</code> 进行编码。 </p>
<p><code>parse()</code> 首先调用 <code>x264_param_default()</code> 为存储参数的结构体 <code>x264_param_t</code> 赋默认值；然后在一个大循环中调用 <code>getopt_long()</code> 逐个解析输入的参数，并作相应的处理；最后调用 <code>select_input()</code> 和 <code>select_output()</code> 解析输入文件格式（例如yuv，y4m…）和输出文件格式（例如raw，flv，MP4…）。</p>
<p><code>encode()</code> 首先调用 <code>x264_encoder_open()</code> 打开H.264编码器，然后调用 <code>x264_encoder_headers()</code> 输出H.264码流的头信息（例如SPS、PPS、SEI），接着进入一个循环并且调用 <code>encode_frame()</code> 逐帧编码视频，最后调用 <code>x264_encoder_close()</code> 关闭解码器。其中 <code>encode_frame()</code> 中又调用了 <code>x264_encoder_encode()</code> 完成了具体的编码工作。下文将会对上述流程展开分析。</p>
<h4 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h4><p><code>main()</code> 的定义很简单，它主要调用了两个函数：<code>parse()</code> 和 <code>encode()</code> 。<code>main()</code> 首先调用 <code>parse()</code> 解析输入的命令行参数，然后调用 <code>encode()</code> 进行编码。下面分别分析这两个函数。</p>
<h4 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h4><p><code>parse()</code> 用于解析命令行输入的参数（存储于 <code>argv[]</code> 中）</p>
<p>下面简单梳理 <code>parse()</code> 的流程：</p>
<p>（1）调用 <code>x264_param_default()</code> 为存储参数的结构体 <code>x264_param_t</code> 赋默认值</p>
<p>（2）调用 <code>x264_param_default_preset()</code> 为 <code>x264_param_t</code> 赋值</p>
<p>（3）在一个大循环中调用 <code>getopt_long()</code> 逐个解析输入的参数，并作相应的处理。举几个例子：</p>
<ul>
<li>a) “-h”：调用 <code>help()</code> 打开帮助菜单。</li>
<li>b) “-V” 调用 <code>print_version_info()</code> 打印版本信息。</li>
<li>c)对于长选项，调用 <code>x264_param_parse()</code> 进行处理。</li>
</ul>
<p>（4）调用 <code>select_input()</code> 解析输出文件格式（例如raw，flv，MP4…）</p>
<p>（5）调用 <code>select_output()</code> 解析输入文件格式（例如yuv，y4m…）</p>
<p>下文按照顺序记录parse()中涉及到的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x264_param_default()</span><br><span class="line">x264_param_default_preset()</span><br><span class="line">help()</span><br><span class="line">print_version_info()</span><br><span class="line">x264_param_parse()</span><br><span class="line">select_input()</span><br><span class="line">select_output()</span><br></pre></td></tr></table></figure>
<p><code>x264_param_default()</code> 是一个x264的API。该函数用于设置x264中 <code>x264_param_t</code> 结构体的默认值。</p>
<p><code>x264_param_default_preset()</code> 是一个 libx264 的 API，用于设置 x264 的 preset 和 tune。</p>
<p>从源代码可以看出，<code>x264_param_default_preset()</code> 调用 <code>x264_param_apply_preset()</code> 设置 preset，调用 <code>x264_param_apply_tune()</code> 设置 tune。记录一下这两个函数。</p>
<p><code>help()</code> 用于打印帮助菜单。在 x264 命令行程序中添加 “-h” 参数后会调用该函数。</p>
<p><code>print_version_info()</code> 用于打印 x264 的版本信息。在x264命令行程序中添加 “-V” 参数后会调用该函数。</p>
<p><code>x264_param_parse()</code> 是一个 x264 的 API。该函数以字符串键值对的方式设置 <code>x264_param_t</code> 结构体的一个成员变量。</p>
<p><code>x264_param_parse()</code> 中判断参数的宏 <code>OPT()</code> 和 <code>OPT2()</code> 实质上就是 <code>strcmp()</code>。由此可见该函数的流程首先是调用 <code>strcmp()</code> 判断当前输入参数的名称 name，然后再调用 <code>atoi()</code>，<code>atof()</code>，或者 <code>atobool()</code> 等将当前输入参数值 value 转换成相应类型的值并赋值给对应的参数。</p>
<p><code>x264_param_apply_profile()</code> 是一个 x264 的 API。该函数用于设置 x264 的 profile</p>
<p><code>select_output()</code> 用于设定输出的文件格式。</p>
<p><code>select_input()</code> 用于设定输入的文件格式。</p>
<h4 id="encode"><a href="#encode" class="headerlink" title="encode()"></a>encode()</h4><p><code>encode()</code> 编码 YUV 为 H.264 码流</p>
<p>从源代码可以梳理出来 <code>encode()</code> 的流程：</p>
<p>（1）调用 <code>x264_encoder_open()</code> 打开 H.264 编码器。</p>
<p>（2）调用 <code>x264_encoder_parameters()</code> 获得当前的参数集 <code>x264_param_t</code>，用于后续步骤中的一些配置。</p>
<p>（3）调用输出格式（H.264裸流、FLV、mp4等）对应 <code>cli_output_t</code> 结构体的 <code>set_param()</code> 方法，为输出格式的封装器设定参数。其中参数源自于上一步骤得到的 <code>x264_param_t</code>。</p>
<p>（4）如果不是在每个keyframe前面都增加 SPS/PPS/SEI 的话，就调用 <code>x264_encoder_headers()</code> 在整个码流前面加 SPS/PPS/SEI。</p>
<p>（5）进入一个循环中进行一帧一帧的将 YUV 编码为 H.264：</p>
<ul>
<li>a)调用输入格式（YUV、Y4M等）对应的 <code>cli_vid_filter_t</code> 结构体 <code>get_frame()</code> 方法，获取一帧YUV数据。</li>
<li>b)调用 <code>encode_frame()</code> 编码该帧YUV数据为H.264数据，并且输出出来。该函数内部调用<code>x264_encoder_encode()</code> 完成编码工作，调用输出格式对应 <code>cli_output_t</code> 结构体的 <code>write_frame()</code> 完成了输出工作。</li>
<li>c)调用输入格式（YUV、Y4M等）对应的 <code>cli_vid_filter_t</code> 结构体 <code>release_frame()</code> 方法，释放刚才获取的 YUV 数据。</li>
<li>d)调用 <code>print_status()</code> 输出一些统计信息。</li>
</ul>
<p>（6）编码即将结束的时候，进入另一个循环，输出编码器中缓存的视频帧：</p>
<ul>
<li>a)不再传递新的YUV数据，直接调用 <code>encode_frame()</code>，将编码器中缓存的剩余几帧数据编码输出出来。</li>
<li>b)调用 <code>print_status()</code> 输出一些统计信息。</li>
</ul>
<p>（7）调用 <code>x264_encoder_close()</code> 关闭 H.264 编码器。</p>
<p><code>encode()</code> 的流程中涉及到 libx264 的几个关键的 API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x264_encoder_open()		<span class="comment">// 打开H.264编码器。</span></span><br><span class="line">x264_encoder_headers()	<span class="comment">// 输出SPS/PPS/SEI。</span></span><br><span class="line">x264_encoder_encode()	<span class="comment">// 编码一帧数据。</span></span><br><span class="line">x264_encoder_close()	<span class="comment">// 关闭H.264编码器。</span></span><br></pre></td></tr></table></figure>
<p>此外上述流程中涉及到两个比较简单的函数：<code>encode_frame()</code> 和 <code>print_status()</code>。其中 <code>encode_frame()</code> 用于编码一帧数据，而 <code>print_status()</code> 用于输出一帧数据编码后的统计信息。下文记录一下这两个函数的定义。</p>
<p><code>encode_frame()</code> 内部调用 <code>x264_encoder_encode()</code> 完成编码工作，调用输出格式对应 <code>cli_output_t</code> 结构体的 <code>write_frame()</code>完成了输出工作。</p>
<p>print_status()的代码不再详细记录，它的输出效果如下图中红框中的文字。</p>
<p><img alt="print_status输出效果" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/print_status.png" data-index="2" data-src="/images/imageFFmpeg/Thor/print_status.png"></p>
<h3 id="X264-控制台程序中和输入输出相关的结构体"><a href="#X264-控制台程序中和输入输出相关的结构体" class="headerlink" title="X264 控制台程序中和输入输出相关的结构体"></a>X264 控制台程序中和输入输出相关的结构体</h3><p>在x264控制台程序中有3个和输入输出相关的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cli_output_t</span>		<span class="comment">// 输出格式对应的结构体。输出格式一般为H.264裸流、FLV、MP4等。</span></span><br><span class="line"><span class="keyword">cli_input_t</span>			<span class="comment">// 输入格式对应的结构体。输入格式一般为纯YUV像素数据，Y4M格式数据等。</span></span><br><span class="line"><span class="keyword">cli_vid_filter_t</span>	<span class="comment">// 输入格式滤镜结构体。滤镜可以对输入数据做一些简单的处理，例如拉伸、裁剪等等（当然滤镜也可以不作任何处理，直接读取输入数据）。</span></span><br></pre></td></tr></table></figure>
<p>在 x264 的编码过程中，调用 <code>cli_vid_filter_t</code> 结构体的 <code>get_frame()</code> 读取 YUV 数据，调用 <code>cli_output_t</code> 的 <code>write_frame()</code> 写入数据。</p>
<h2 id="编码器主干部分"><a href="#编码器主干部分" class="headerlink" title="编码器主干部分"></a>编码器主干部分</h2><p>“主干部分”指的就是libx264中最核心的接口函数—— <code>x264_encoder_encode()</code> ，以及相关的几个接口函数<code>x264_encoder_open()</code>，<code>x264_encoder_headers()</code>，和 <code>x264_encoder_close()</code>。</p>
<h3 id="函数调用关系图-2"><a href="#函数调用关系图-2" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="X264编码器主干部分的函数调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/X264编码器主干部分的函数调用关系.png" data-index="3" data-src="/images/imageFFmpeg/Thor/X264编码器主干部分的函数调用关系.png"></p>
<p>从图中可以看出，x264 主干部分最复杂的函数就是 <code>x264_encoder_encode()</code>，该函数完成了编码一帧 YUV 为H.264 码流的工作。与之配合的还有打开编码器的函数 <code>x264_encoder_open()</code>，关闭编码器的函数 <code>x264_encoder_close()</code>，以及输出 SPS/PPS/SEI 这样的头信息的 <code>x264_encoder_headers()</code>。</p>
<p><code>x264_encoder_open()</code> 用于打开编码器，其中初始化了 libx264 编码所需要的各种变量。它调用了下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x264_validate_parameters()	<span class="comment">// 检查输入参数（例如输入图像的宽高是否为正数）。</span></span><br><span class="line">x264_predict_16x16_init()	<span class="comment">// 初始化Intra16x16帧内预测汇编函数。</span></span><br><span class="line">x264_predict_4x4_init()		<span class="comment">// 初始化Intra4x4帧内预测汇编函数。</span></span><br><span class="line">x264_pixel_init()			<span class="comment">// 初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。</span></span><br><span class="line">x264_dct_init()				<span class="comment">// 初始化DCT变换和DCT反变换相关的汇编函数。</span></span><br><span class="line">x264_mc_init()				<span class="comment">// 初始化运动补偿相关的汇编函数。</span></span><br><span class="line">x264_quant_init()			<span class="comment">// 初始化量化和反量化相关的汇编函数。</span></span><br><span class="line">x264_deblock_init()			<span class="comment">// 初始化去块效应滤波器相关的汇编函数。</span></span><br><span class="line">x264_lookahead_init()		<span class="comment">// 初始化Lookahead相关的变量。</span></span><br><span class="line">x264_ratecontrol_new()		<span class="comment">// 初始化码率控制相关的变量。</span></span><br></pre></td></tr></table></figure>
<p><code>x264_encoder_headers()</code> 输出 SPS/PPS/SEI 这些 H.264 码流的头信息。它调用了下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x264_sps_write()			<span class="comment">// 输出SPS</span></span><br><span class="line">x264_pps_write()			<span class="comment">// 输出PPS</span></span><br><span class="line">x264_sei_version_write()	<span class="comment">// 输出SEI</span></span><br></pre></td></tr></table></figure>
<p><code>x264_encoder_encode()</code> 编码一帧 YUV 为 H.264 码流。它调用了下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x264_frame_pop_unused()	<span class="comment">// 获取1个x264_frame_t类型结构体fenc。如果frames.unused[]队列不为空，就调用x264_frame_pop()从unused[]队列取1个现成的；否则就调用x264_frame_new()创建一个新的。</span></span><br><span class="line">x264_frame_copy_picture() <span class="comment">// 将输入的图像数据拷贝至fenc。</span></span><br><span class="line">x264_lookahead_put_frame()  <span class="comment">// 将fenc放入lookahead.next.list[]队列，等待确定帧类型。</span></span><br><span class="line">x264_lookahead_get_frames() <span class="comment">// 通过lookahead分析帧类型。该函数调用了x264_slicetype_decide()，x264_slicetype_analyse()和x264_slicetype_frame_cost()等函数。经过一些列分析之后，最终确定了帧类型信息，并且将帧放入frames.current[]队列。</span></span><br><span class="line">x264_frame_shift() <span class="comment">// 从frames.current[]队列取出1帧用于编码。</span></span><br><span class="line">x264_reference_update() <span class="comment">// 更新参考帧列表。</span></span><br><span class="line">x264_reference_reset() <span class="comment">// 如果为IDR帧，调用该函数清空参考帧列表。</span></span><br><span class="line">x264_reference_hierarchy_reset() <span class="comment">// 如果是I（非IDR帧）、P帧、B帧（可做为参考帧），调用该函数。</span></span><br><span class="line">x264_reference_build_list() <span class="comment">// 创建参考帧列表list0和list1。</span></span><br><span class="line">x264_ratecontrol_start() <span class="comment">// 开启码率控制。</span></span><br><span class="line">x264_slice_init() <span class="comment">// 创建 Slice Header。</span></span><br><span class="line">x264_slices_write() <span class="comment">// 编码数据（最关键的步骤）。其中调用了x264_slice_write()完成了编码的工作（注意“x264_slices_write()”和“x264_slice_write()”名字差了一个“s”）。</span></span><br><span class="line">x264_encoder_frame_end() <span class="comment">// 编码结束后做一些后续处理，例如记录一些统计信息。其中调用了x264_frame_push_unused()将fenc重新放回frames.unused[]队列，并且调用x264_ratecontrol_end()关闭码率控制。</span></span><br></pre></td></tr></table></figure>
<p><code>x264_encoder_close()</code> 用于关闭解码器，同时输出一些统计信息。它调用了下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x264_lookahead_delete()		<span class="comment">// 释放Lookahead相关的变量。</span></span><br><span class="line">x264_ratecontrol_summary()	<span class="comment">// 汇总码率控制信息。</span></span><br><span class="line">x264_ratecontrol_delete()	<span class="comment">// 关闭码率控制。</span></span><br></pre></td></tr></table></figure>
<h4 id="x264-encoder-open"><a href="#x264-encoder-open" class="headerlink" title="x264_encoder_open()"></a>x264_encoder_open()</h4><p><code>x264_encoder_open()</code> 是一个 libx264 的 API。该函数用于打开编码器，其中初始化了 libx264 编码所需要的各种变量。</p>
<p>根据函数调用的顺序，看一下 <code>x264_encoder_open()</code> 调用的下面几个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x264_sps_init()				<span class="comment">// 根据输入参数生成H.264码流的SPS信息。</span></span><br><span class="line">x264_pps_init()				<span class="comment">// 根据输入参数生成H.264码流的PPS信息。</span></span><br><span class="line">x264_predict_16x16_init()	<span class="comment">// 初始化Intra16x16帧内预测汇编函数。</span></span><br><span class="line">x264_predict_4x4_init()		<span class="comment">// 初始化Intra4x4帧内预测汇编函数。</span></span><br><span class="line">x264_pixel_init()			<span class="comment">// 初始化像素值计算相关的汇编函数（包括SAD、SATD、SSD等）。</span></span><br><span class="line">x264_dct_init()				<span class="comment">// 初始化DCT变换和DCT反变换相关的汇编函数。</span></span><br><span class="line">x264_mc_init()				<span class="comment">// 初始化运动补偿相关的汇编函数。</span></span><br><span class="line">x264_quant_init()			<span class="comment">// 初始化量化和反量化相关的汇编函数。</span></span><br><span class="line">x264_deblock_init()			<span class="comment">// 初始化去块效应滤波器相关的汇编函数。</span></span><br><span class="line">mbcmp_init()				<span class="comment">// 决定像素比较的时候使用SAD还是SATD。</span></span><br></pre></td></tr></table></figure>
<h4 id="相关知识简述"><a href="#相关知识简述" class="headerlink" title="相关知识简述"></a>相关知识简述</h4><p>简单记录一下帧内预测的方法。帧内预测根据宏块左边和上边的边界像素值推算宏块内部的像素值，帧内预测的效果如下图所示。其中左边的图为图像原始画面，右边的图为经过帧内预测后没有叠加残差的画面。</p>
<p><img alt="帧内预测-01" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-01.png" data-index="4" data-src="/images/imageFFmpeg/Thor/帧内预测-01.png"></p>
<p>H.264 中有两种帧内预测模式：<code>16x16</code> 亮度帧内预测模式和 <code>4x4</code> 亮度帧内预测模式。其中 <code>16x16</code> 帧内预测模式一共有 4 种，如下图所示。</p>
<p><img alt="帧内预测-02" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-02.png" data-index="5" data-src="/images/imageFFmpeg/Thor/帧内预测-02.png"></p>
<p>这 4 种模式列表如下。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vertical</td>
<td>由上边像素推出相应像素值</td>
</tr>
<tr>
<td>Horizontal</td>
<td>由左边像素推出相应像素值</td>
</tr>
<tr>
<td>DC</td>
<td>由上边和左边像素平均值推出相应像素值</td>
</tr>
<tr>
<td>Plane</td>
<td>由上边和左边像素推出相应像素值</td>
</tr>
</tbody>
</table>
<p><code>4x4</code> 帧内预测模式一共有 9 种，如下图所示。</p>
<p><img alt="帧内预测-03" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-03.png" data-index="6" data-src="/images/imageFFmpeg/Thor/帧内预测-03.png"></p>
<p>简单记录几个像素计算中的概念。SAD 和 SATD 主要用于帧内预测模式以及帧间预测模式的判断。有关 SAD、SATD、SSD 的定义如下：</p>
<blockquote>
<p>SAD（Sum of Absolute Difference）也可以称为SAE（Sum of Absolute Error），即绝对误差和。它的计算方法就是求出两个像素块对应像素点的差值，将这些差值分别求绝对值之后再进行累加。</p>
<p>SATD（Sum of Absolute Transformed Difference）即Hadamard变换后再绝对值求和。它和SAD的区别在于多了一个“变换”。</p>
<p>SSD（Sum of Squared Difference）也可以称为SSE（Sum of Squared Error），即差值的平方和。它和SAD的区别在于多了一个“平方”。</p>
</blockquote>
<p>H.264中使用SAD和SATD进行宏块预测模式的判断。早期的编码器使用SAD进行计算，近期的编码器多使用SATD进行计算。为什么使用SATD而不使用SAD呢？关键原因在于编码之后码流的大小是和图像块DCT变换后频域信息紧密相关的，而和变换前的时域信息关联性小一些。SAD只能反应时域信息；SATD却可以反映频域信息，而且计算复杂度也低于DCT变换，因此是比较合适的模式选择的依据。</p>
<p>使用SAD进行模式选择的示例如下所示。下面这张图代表了一个普通的 <code>Intra16x16</code> 的宏块的像素。它的下方包含了使用Vertical，Horizontal，DC和Plane四种帧内预测模式预测的像素。通过计算可以得到这几种预测像素和原始像素之间的SAD（SAE）分别为3985，5097，4991，2539。由于Plane模式的SAD取值最小，由此可以断定Plane模式对于这个宏块来说是最好的帧内预测模式。</p>
<p><img alt="帧内预测-04" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-04.png" data-index="7" data-src="/images/imageFFmpeg/Thor/帧内预测-04.png"></p>
<p><img alt="帧内预测-05" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-05.png" data-index="8" data-src="/images/imageFFmpeg/Thor/帧内预测-05.png"></p>
<p>简单记录一下DCT相关的知识。DCT变换的核心理念就是把图像的低频信息（对应大面积平坦区域）变换到系数矩阵的左上角，而把高频信息变换到系数矩阵的右下角，这样就可以在压缩的时候（量化）去除掉人眼不敏感的高频信息（位于矩阵右下角的系数）从而达到压缩数据的目的。二维 <code>8x8</code> DCT变换常见的示意图如下所示。</p>
<p><img alt="帧内预测-06" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-06.png" data-index="9" data-src="/images/imageFFmpeg/Thor/帧内预测-06.png"></p>
<p>早期的DCT变换都使用了 <code>8x8</code> 的矩阵（变换系数为小数）。在 H.264 标准中新提出了一种 <code>4x4</code> 的矩阵。这种 <code>4x4</code> DCT变换的系数都是整数，一方面提高了运算的准确性，一方面也利于代码的优化。<code>4x4</code> 整数DCT变换的示意图如下所示（作为对比，右侧为 <code>4x4</code> 块的Hadamard变换的示意图）。</p>
<p><img alt="帧内预测-07" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-07.png" data-index="10" data-src="/images/imageFFmpeg/Thor/帧内预测-07.png"></p>
<p>简单记录一下半像素插值的知识。《H.264标准》中规定，运动估计为 <code>1/4</code> 像素精度。因此在H.264编码和解码的过程中，需要将画面中的像素进行插值——简单地说就是把原先的 1 个像素点拓展成 <code>4x4</code> 一共16个点。下图显示了H.264编码和解码过程中像素插值情况。可以看出原先的 G 点的右下方通过插值的方式产生了a、b、c、d等一共 16 个点。</p>
<p><img alt="帧内预测-08" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-08.png" data-index="11" data-src="/images/imageFFmpeg/Thor/帧内预测-08.png"></p>
<p>如图所示，<code>1/4</code> 像素内插一般分成两步：</p>
<p>（1）半像素内插。这一步通过 6 抽头滤波器获得 5 个半像素点。</p>
<p>（2）线性内插。这一步通过简单的线性内插获得剩余的 <code>1/4</code> 像素点。</p>
<p>图中半像素内插点为 b、m、h、s、j 五个点。半像素内插方法是对整像素点进行 6 抽头滤波得出，滤波器的权重为( <code>1/32, -5/32, 5/8, 5/8, -5/32, 1/32</code> )。例如 b 的计算公式为：</p>
<p><strong><code>b=round( (E - 5F + 20G + 20H - 5I + J ) / 32)</code></strong></p>
<p>剩下几个半像素点的计算关系如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m：由B、D、H、N、S、U计算</span><br><span class="line">h：由A、C、G、M、R、T计算</span><br><span class="line">s：由K、L、M、N、P、Q计算</span><br><span class="line">j：由cc、dd、h、m、ee、ff计算。需要注意j点的运算量比较大，因为cc、dd、ee、ff都需要通过半像素内插方法进行计算。</span><br></pre></td></tr></table></figure>
<p>在获得半像素点之后，就可以通过简单的线性内插获得 <code>1/4</code> 像素内插点了。<code>1/4</code> 像素内插的方式如下图所示。例如图中 a 点的计算公式如下：</p>
<p><strong><code>A=round( (G+b)/2 )</code></strong></p>
<p>在这里有一点需要注意：位于 4 个角的e、g、p、r 四个点并不是通过 j 点计算计算的，而是通过b、h、s、m四个半像素点计算的。</p>
<p><img alt="帧内预测-09" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/帧内预测-09.png" data-index="12" data-src="/images/imageFFmpeg/Thor/帧内预测-09.png"></p>
<h4 id="x264-encoder-headers"><a href="#x264-encoder-headers" class="headerlink" title="x264_encoder_headers()"></a>x264_encoder_headers()</h4><p><code>x264_encoder_headers()</code> 是libx264的一个API函数，用于输出 SPS/PPS/SEI 这些 H.264 码流的头信息。</p>
<h4 id="x264-encoder-close"><a href="#x264-encoder-close" class="headerlink" title="x264_encoder_close()"></a>x264_encoder_close()</h4><p><code>x264_encoder_close()</code> 是libx264的一个API函数。该函数用于关闭编码器，同时输出一些统计信息。</p>
<h4 id="x264-encoder-encode"><a href="#x264-encoder-encode" class="headerlink" title="x264_encoder_encode()"></a>x264_encoder_encode()</h4><p><code>x264_encoder_encode()</code> 是libx264的API函数，用于编码一帧 YUV 为 H.264 码流。</p>
<p><code>x264_encoder_encode()</code> 的流程大致如下：</p>
<p>（1）调用 <code>x264_frame_pop_unused</code> 获取一个空的 <code>fenc</code>（x264_frame_t类型）用于存储一帧编码像素数据。</p>
<p>（2）调用 <code>x264_frame_copy_picture()</code> 将外部结构体的 <code>pic_in</code>（<code>x264_picture_t</code>类型）的数据拷贝给内部结构体的 <code>fenc</code>（<code>x264_frame_t</code> 类型）。</p>
<p>（3）调用 <code>x264_lookahead_put_frame()</code> 将 <code>fenc</code> 放入 Lookahead 模块的队列中，等待确定帧类型。</p>
<p>（4）调用 <code>x264_lookahead_get_frames()</code> 分析 Lookahead 模块中一个帧的帧类型。分析后的帧保存在<code>frames.current[]</code> 中。</p>
<p>（5）调用 <code>x264_frame_shift()</code> 从 <code>frames.current[]</code> 中取出分析帧类型之后的 <code>fenc</code>。</p>
<p>（6）调用 <code>x264_reference_update()</code> 更新参考帧队列 <code>frames.reference[]</code>。</p>
<p>（7）如果编码帧 <code>fenc</code> 是 <code>IDR</code> 帧，调用 <code>x264_reference_reset()</code> 清空参考帧队列 <code>frames.reference[]</code>。</p>
<p>（8）调用 <code>x264_reference_build_list()</code> 创建参考帧列表 <code>List0</code> 和 <code>List1</code>。</p>
<p>（9）根据选项做一些配置：</p>
<ul>
<li>a) 如果 <code>b_aud</code> 不为 0，输出 AUD 类型 NALU</li>
<li>b) 在当前帧是关键帧的情况下，如果 <code>b_repeat_headers</code> 不为 0，调用 <code>x264_sps_write()</code> 和 <code>x264_pps_write()</code> 输出 SPS 和 PPS。</li>
<li>c) 输出一些特殊的 SEI 信息，用于适配各种解码器。</li>
</ul>
<p>（10）调用 <code>x264_slice_init()</code> 初始化 Slice Header 信息。</p>
<p>（11）调用 <code>x264_slices_write()</code> 进行编码。该部分是 libx264 的核心，在后续文章中会详细分析。</p>
<p>（12）调用 <code>x264_encoder_frame_end()</code> 做一些编码后的后续处理。</p>
<p><code>x264_slice_write()</code> 是完成编码工作的函数。该函数中包含了去块效应滤波，运动估计，宏块编码，熵编码等模块。</p>
<h2 id="x264-slice-write-1"><a href="#x264-slice-write-1" class="headerlink" title="x264_slice_write()"></a>x264_slice_write()</h2><p><code>x264_slice_write()</code> 是 x264 项目的核心，它完成了编码了一个 Slice 的工作。根据功能的不同，该函数可以分为滤波（Filter），分析（Analysis），宏块编码（Encode）和熵编码（Entropy Encoding）几个子模块。</p>
<h3 id="函数调用关系图-3"><a href="#函数调用关系图-3" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="x264_slice_write" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/x264_slice_write.png" data-index="13" data-src="/images/imageFFmpeg/Thor/x264_slice_write.png"></p>
<p>x264_slice_write()调用了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x264_nal_start()	<span class="comment">// 开始写一个NALU。</span></span><br><span class="line">x264_macroblock_thread_init() <span class="comment">// 初始化宏块重建数据缓存fdec_buf[]和编码数据缓存fenc_buf[]。</span></span><br><span class="line">x264_slice_header_write()	<span class="comment">// 输出 Slice Header。</span></span><br><span class="line">x264_fdec_filter_row()	<span class="comment">// 滤波模块。该模块包含了环路滤波，半像素插值，SSIM/PSNR的计算。</span></span><br><span class="line">x264_macroblock_cache_load() 	<span class="comment">// 将要编码的宏块的周围的宏块的信息读进来。</span></span><br><span class="line">x264_macroblock_analyse()	<span class="comment">// 分析模块。该模块包含了帧内预测模式分析以及帧间运动估计等。</span></span><br><span class="line">x264_macroblock_encode()	<span class="comment">// 宏块编码模块。该模块通过对残差的DCT变换、量化等方式对宏块进行编码。</span></span><br><span class="line">x264_macroblock_write_cabac()	<span class="comment">// CABAC熵编码模块。</span></span><br><span class="line">x264_macroblock_write_cavlc()	<span class="comment">// CAVLC熵编码模块。</span></span><br><span class="line">x264_macroblock_cache_save()	<span class="comment">// 保存当前宏块的信息。</span></span><br><span class="line">x264_ratecontrol_mb()	<span class="comment">// 码率控制。</span></span><br><span class="line">x264_nal_end() <span class="comment">// 结束写一个NALU。</span></span><br></pre></td></tr></table></figure>
<p>根据源代码简单梳理了 <code>x264_slice_write()</code> 的流程，如下所示：</p>
<p>（1）调用 <code>x264_nal_start()</code> 开始输出一个 NALU。</p>
<p>（2）<code>x264_macroblock_thread_init()</code>：初始化宏块重建像素缓存 <code>fdec_buf[]</code> 和编码像素缓存 <code>fenc_buf[]</code>。</p>
<p>（3）调用 <code>x264_slice_header_write()</code> 输出 Slice Header。</p>
<p>（4）进入一个循环，该循环每执行一遍编码一个宏块：</p>
<ul>
<li>a) 每处理一行宏块，调用一次 <code>x264_fdec_filter_row()</code> 执行滤波模块。</li>
<li>b) 调用 <code>x264_macroblock_cache_load_progressive()</code> 将要编码的宏块的周围的宏块的信息读进来。</li>
<li>c) 调用 <code>x264_macroblock_analyse()</code> 执行分析模块。</li>
<li>d) 调用 <code>x264_macroblock_encode()</code> 执行宏块编码模块。</li>
<li>e) 调用 <code>x264_macroblock_write_cabac()/x264_macroblock_write_cavlc()</code> 执行熵编码模块。</li>
<li>f) 调用 <code>x264_macroblock_cache_save()</code> 保存当前宏块的信息。</li>
<li>g) 调用 <code>x264_ratecontrol_mb()</code> 执行码率控制。</li>
<li>h) 准备处理下一个宏块。</li>
</ul>
<p>（5）调用 <code>x264_nal_end()</code> 结束输出一个 NALU。</p>
<h3 id="重要的数据结构"><a href="#重要的数据结构" class="headerlink" title="重要的数据结构"></a>重要的数据结构</h3><p>X264在宏块编码方面涉及到下面几个比较重要的结构体：</p>
<p>宏块像素存储缓存  <code>fenc_buf[]</code> 和 <code>fdec_buf[]</code> ——位于 <code>x264_t.mb.pic</code> 中，用于存储宏块的亮度和色度像素。<br>宏块各种信息的缓存 Cache——位于 <code>x264_t.mb.pic</code> 中，用于存储宏块的信息例如 <code>4x4</code> 帧内预测模式、DCT 的非 0 系数个数、运动矢量、参考帧序号等。</p>
<p>图像半像素点存储空间 <code>filtered[]</code> ——位于 <code>x264_frame_t</code> 中，用于存储半像素插值后的点。</p>
<h4 id="宏块像素存储缓存-fenc-buf-和-fdec-buf"><a href="#宏块像素存储缓存-fenc-buf-和-fdec-buf" class="headerlink" title="宏块像素存储缓存 fenc_buf[] 和 fdec_buf[]"></a>宏块像素存储缓存 fenc_buf[] 和 fdec_buf[]</h4><p><code>fenc_buf[]</code> 和 <code>fdec_buf[]</code> 为 <code>x264_t.mb.cache</code> 中的结构体，用于存储一个宏块的像素数据。其中 <code>fenc_buf[]</code> 用于存储宏块编码像素数据，而 <code>fdec_buf[]</code> 用于存储宏块重建像素数据。他们的定义如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* space for p_fenc and p_fdec */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FENC_STRIDE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDEC_STRIDE 32</span></span><br><span class="line"><span class="comment">//存储编码宏块fenc和重建宏块fdec的内存</span></span><br><span class="line"><span class="keyword">uint8_t</span> fenc_buf[<span class="number">48</span>*FENC_STRIDE]</span><br><span class="line"><span class="keyword">uint8_t</span> fdec_buf[<span class="number">52</span>*FDEC_STRIDE]</span><br></pre></td></tr></table></figure>
<p>从定义可以看出，<code>fenc_buf[]</code> 每行 16 个数据；而 <code>fdec_buf[]</code> 每行 32 个数据。在 <code>x264_t.mb.cache</code> 中和 <code>fenc_buf[]</code> 和 <code>fdec_buf[]</code> 相关的指针数组还有 <code>p_fenc[3]</code> 和 <code>p_fdec[3]</code> ，它们中的 3 个元素 <code>[0]、[1]、[2]</code> 分别指向分别指向对应缓存 buf 的 Y、U、V 分量。下图画出了像素格式为 YUV420P 的时候 <code>fenc_buf[]</code> 的存储示意图。图中灰色区域存储 Y，蓝色区域存储 U，粉红区域存储 V。<code>p_fenc[0]</code> 指向 Y 的存储区域，<code>p_fenc[1]</code> 指向 U 的存储区域，<code>p_fenc[2]</code> 指向 V 的存储区域，在图中以方框的形式标注了出来。</p>
<p><img alt="像素格式为 YUV420P 的时候 fenc_buf 的存储" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/x264-01.png" data-index="14" data-src="/images/imageFFmpeg/Thor/x264-01.png"></p>
<p>下图画出了像素格式为 YUV420P 的时候 <code>fdec_buf[]</code> 的存储示意图。图中灰色区域存储 Y，蓝色区域存储 U，粉红区域存储 V。<code>p_fenc[0]</code> 指向 Y 的存储区域，<code>p_fenc[1]</code> 指向 U 的存储区域，<code>p_fenc[2]</code> 指向 V 的存储区域，在图中以方框的形式标注了出来。</p>
<p><img alt="像素格式为 YUV420P 的时候 fdec_buf 的存储" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/x264-02.png" data-index="15" data-src="/images/imageFFmpeg/Thor/x264-02.png"></p>
<p>从图中可以看出，<code>fdec_buf[]</code> 和 <code>fenc_buf[]</code> 主要的区别在于 <code>fdec_buf[]</code> 像素块的左边和上边包含了左上方相邻块用于预测的像素。</p>
<h3 id="宏块各种信息的缓存Cache"><a href="#宏块各种信息的缓存Cache" class="headerlink" title="宏块各种信息的缓存Cache"></a>宏块各种信息的缓存Cache</h3><p>在 x264 中 <code>x264_t.mb.cache</code> 结构体中包含了存储宏块信息的各种各样的缓存 Cache。例如：</p>
<ul>
<li><strong>intra4x4_pred_mode</strong>：<code>Intra4x4</code> 帧内预测模式的缓存</li>
<li><strong>non_zero_count</strong>：DCT 的非 0 系数个数的缓存</li>
<li><strong>mv</strong>：运动矢量缓存</li>
<li><strong>ref</strong>：运动矢量参考帧的缓存</li>
</ul>
<h2 id="滤波（Filter）部分"><a href="#滤波（Filter）部分" class="headerlink" title="滤波（Filter）部分"></a>滤波（Filter）部分</h2><p><code>x264_fdec_filter_row()</code> 对应着 x264 中的滤波模块。滤波模块主要完成了下面 3 个方面的功能：</p>
<p>（1）环路滤波（去块效应滤波）</p>
<p>（2）半像素内插</p>
<p>（3）视频质量指标PSNR和SSIM的计算</p>
<h3 id="函数调用关系图-4"><a href="#函数调用关系图-4" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="滤波（Filter）部分的函数调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/x264_fdec_filter_row.png" data-index="16" data-src="/images/imageFFmpeg/Thor/x264_fdec_filter_row.png"></p>
<p>从图中可以看出，滤波模块对应的x264_fdec_filter_row()调用了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x264_frame_deblock_row()	<span class="comment">// 去块效应滤波器。</span></span><br><span class="line">x264_frame_filter()			<span class="comment">// 半像素插值。</span></span><br><span class="line">x264_pixel_ssd_wxh()		<span class="comment">// PSNR计算。</span></span><br><span class="line">x264_pixel_ssim_wxh()		<span class="comment">// SSIM计算。</span></span><br></pre></td></tr></table></figure>
<p>从源代码可以看出，<code>x264_fdec_filter_row()</code> 完成了三步工作：</p>
<p>（1）环路滤波（去块效应滤波）。通过调用 <code>x264_frame_deblock_row()</code> 实现。</p>
<p>（2）半像素内插。通过调用 <code>x264_frame_filter()</code> 实现。</p>
<p>（3）视频质量 SSIM 和 PSNR 计算。PSNR在这里只计算了 SSD，通过调用 <code>x264_pixel_ssd_wxh()</code> 实现；SSIM 的计算则是通过 <code>x264_pixel_ssim_wxh()</code> 实现。</p>
<h2 id="宏块分析（Analysis）部分-帧内宏块（Intra）"><a href="#宏块分析（Analysis）部分-帧内宏块（Intra）" class="headerlink" title="宏块分析（Analysis）部分-帧内宏块（Intra）"></a>宏块分析（Analysis）部分-帧内宏块（Intra）</h2><p><code>x264_macroblock_analyse()</code> 对应着 x264 中的分析模块。分析模块主要完成了下面 2 个方面的功能：</p>
<p>（1）对于帧内宏块，分析帧内预测模式</p>
<p>（2）对于帧间宏块，进行运动估计，分析帧间预测模式</p>
<h3 id="函数调用关系图-5"><a href="#函数调用关系图-5" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="宏块分析（Analysis）部分的函数调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/x264_macroblock_analyse.png" data-index="17" data-src="/images/imageFFmpeg/Thor/x264_macroblock_analyse.png"></p>
<p>从图中可以看出，分析模块的 <code>x264_macroblock_analyse()</code> 调用了如下函数（只列举了几个有代表性的函数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x264_mb_analyse_init()			<span class="comment">// Analysis模块初始化。</span></span><br><span class="line">x264_mb_analyse_intra()			<span class="comment">// Intra宏块帧内预测模式分析。</span></span><br><span class="line">x264_macroblock_probe_pskip()	<span class="comment">// 分析是否是skip模式。</span></span><br><span class="line">x264_mb_analyse_inter_p16x16()	<span class="comment">// P16x16宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_p8x8()	<span class="comment">// P8x8宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_p16x8()	<span class="comment">// P16x8宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_b16x16()	<span class="comment">// B16x16宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_b8x8()	<span class="comment">// B8x8宏块帧间预测模式分析。</span></span><br><span class="line">x264_mb_analyse_inter_b16x8()	<span class="comment">// B16x8宏块帧间预测模式分析。</span></span><br></pre></td></tr></table></figure>
<p>尽管 <code>x264_macroblock_analyse()</code> 的源代码比较长，但是它的逻辑比较清晰，如下所示：</p>
<p>（1）如果当前是 <code>I</code> Slice，调用 <code>x264_mb_analyse_intra()</code> 进行 Intra 宏块的帧内预测模式分析。</p>
<p>（2）如果当前是 <code>P</code> Slice，则进行下面流程的分析：</p>
<ul>
<li>a)调用 <code>x264_macroblock_probe_pskip()</code> 分析是否为 Skip 宏块，如果是的话则不再进行下面分析。</li>
<li>b)调用 <code>x264_mb_analyse_inter_p16x16()</code> 分析 <code>P16x16</code> 帧间预测的代价。</li>
<li>c)调用 <code>x264_mb_analyse_inter_p8x8()</code> 分析 <code>P8x8</code> 帧间预测的代价。</li>
<li>d)如果 <code>P8x8</code> 代价值小于 <code>P16x16</code>，则依次对 4 个 <code>8x8</code> 的子宏块分割进行判断：<ul>
<li>i.调用 <code>x264_mb_analyse_inter_p4x4()</code> 分析 <code>P4x4</code> 帧间预测的代价。</li>
<li>ii.如果 <code>P4x4</code> 代价值小于 <code>P8x8</code> ，则调用 <code>x264_mb_analyse_inter_p8x4()</code> 和<code>x264_mb_analyse_inter_p4x8()</code> 分析 <code>P8x4</code> 和 <code>P4x8</code> 帧间预测的代价。</li>
</ul>
</li>
<li>e)如果 <code>P8x8</code> 代价值小于 <code>P16x16</code>，调用 <code>x264_mb_analyse_inter_p16x8()</code> 和<code>x264_mb_analyse_inter_p8x16()</code> 分析 <code>P16x8</code> 和 <code>P8x16</code> 帧间预测的代价。</li>
<li>f)此外还要调用 <code>x264_mb_analyse_intra()</code> ，检查当前宏块作为 Intra 宏块编码的代价是否小于作为 <code>P</code> 宏块编码的代价（<code>P</code> Slice中也允许有 Intra 宏块）。</li>
</ul>
<p>（3）如果当前是 <code>B</code> Slice，则进行和 <code>P</code> Slice类似的处理。</p>
<p>总体说来 <code>x264_mb_analyse_intra()</code> 通过计算 <code>Intra16x16</code>，<code>Intra8x8</code>（暂时没有研究），<code>Intra4x4</code> 这 3 中帧内预测模式的代价，比较后得到最佳的帧内预测模式。该函数的等流程大致如下：</p>
<p>（1）进行 <code>Intra16X16</code> 模式的预测</p>
<ul>
<li>a)调用 <code>predict_16x16_mode_available()</code> 根据周围宏块的情况判断其可用的预测模式（主要检查左边和上边的块是否可用）。</li>
<li>b)循环计算 4 种 <code>Intra16x16</code> 帧内预测模式：<ul>
<li>i.调用 <code>predict_16x16[]()</code> 汇编函数进行 <code>Intra16x16</code> 帧内预测</li>
<li>ii.调用 <code>x264_pixel_function_t</code> 中的 <code>mbcmp[]()</code> 计算编码代价（<code>mbcmp[]()</code> 指向 SAD 或者 SATD 汇编函数）。</li>
</ul>
</li>
<li>c)获取最小代价的 <code>Intra16x16</code> 模式。</li>
</ul>
<p>（2）进行 <code>Intra8x8</code> 模式的预测（未研究，流程应该类似）</p>
<p>（3）进行 <code>Intra4X4</code> 块模式的预测</p>
<ul>
<li>a)循环处理 16 个 <code>4x4</code> 的块：<ul>
<li>i.调用 <code>x264_mb_predict_intra4x4_mode()</code> 根据周围宏块情况判断该块可用的预测模式。</li>
<li>ii.循环计算 9 种 <code>Intra4x4</code> 的帧内预测模式：<ul>
<li>1)调用 <code>predict_4x4 []()</code> 汇编函数进行 <code>Intra4x4</code> 帧内预测</li>
<li>2)调用 <code>x264_pixel_function_t</code> 中的 <code>mbcmp[]()</code> 计算编码代价（<code>mbcmp[]()</code> 指向 SAD 或者 SATD 汇编函数）。</li>
</ul>
</li>
<li>iii.获取最小代价的 <code>Intra4x4</code> 模式。</li>
</ul>
</li>
<li>b)将 16 个 <code>4X4</code> 块的最小代价相加，得到总代价。</li>
</ul>
<p>（4）将上述 3 中模式的代价进行对比，取最小者为当前宏块的帧内预测模式。</p>
<h2 id="宏块分析（Analysis）部分-帧间宏块（Inter）"><a href="#宏块分析（Analysis）部分-帧间宏块（Inter）" class="headerlink" title="宏块分析（Analysis）部分-帧间宏块（Inter）"></a>宏块分析（Analysis）部分-帧间宏块（Inter）</h2><p><code>x264_macroblock_analyse()</code> 对应着 x264 中的分析模块。分析模块主要完成了下面 2 个方面的功能：</p>
<p>（1）对于帧内宏块，分析帧内预测模式</p>
<p>（2）对于帧间宏块，进行运动估计，分析帧间预测模式</p>
<blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/45936267" target="_blank" rel="noopener">详细功能说明</a></p>
</blockquote>
<h2 id="宏块编码（Encode）部分"><a href="#宏块编码（Encode）部分" class="headerlink" title="宏块编码（Encode）部分"></a>宏块编码（Encode）部分</h2><p><code>x264_macroblock_encode()</code> 对应着 x264 中的宏块编码模块。宏块编码模块主要完成了 DCT 变换和量化两个步骤。</p>
<h3 id="函数调用关系图-6"><a href="#函数调用关系图-6" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="宏块编码（Encode）部分的函数调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/x264_macroblock_encode.png" data-index="18" data-src="/images/imageFFmpeg/Thor/x264_macroblock_encode.png"></p>
<p>从图中可以看出，宏块编码模块的 <code>x264_macroblock_encode()</code> 调用了 <code>x264_macroblock_encode_internal()</code> ，而 <code>x264_macroblock_encode_internal()</code> 完成了如下功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x264_macroblock_encode_skip()	<span class="comment">// 编码Skip类型宏块。</span></span><br><span class="line">x264_mb_encode_i16x16()			<span class="comment">// 编码Intra16x16类型的宏块。该函数除了进行DCT变换之外，还对16个小块的DC系数进行了Hadamard变换。</span></span><br><span class="line">x264_mb_encode_i4x4()			<span class="comment">// 编码Intra4x4类型的宏块。</span></span><br><span class="line"><span class="comment">// 帧间宏块编码：这一部分代码直接写在了函数体里面。</span></span><br><span class="line">x264_mb_encode_chroma()			<span class="comment">// 编码色度块。</span></span><br></pre></td></tr></table></figure>
<p><code>x264_macroblock_encode()</code> 用于编码宏块。该函数的定义位于 <code>encoder\macroblock.c</code></p>
<p><code>x264_macroblock_encode_internal()</code> 的流程大致如下：</p>
<p>（1）如果是 Skip 类型，调用 <code>x264_macroblock_encode_skip()</code> 编码宏块。</p>
<p>（2）如果是 <code>Intra16x16</code> 类型，调用 <code>x264_mb_encode_i16x16()</code> 编码宏块。</p>
<p>（3）如果是 <code>Intra4x4</code> 类型，循环 16 次调用 <code>x264_mb_encode_i4x4()</code> 编码宏块。</p>
<p>（4）如果是 Inter 类型，则不再调用子函数，而是直接进行编码：</p>
<ul>
<li>a)对 <code>16x16</code> 块调用 <code>x264_dct_function_t</code> 的 <code>sub16x16_dct()</code> 汇编函数，求得编码宏块数据 <code>p_fenc</code> 与重建宏块数据 <code>p_fdec</code> 之间的残差（“sub”），并对残差进行 DCT 变换。</li>
<li>b)分成 4 个 <code>8x8</code> 的块，对每个 <code>8x8</code> 块分别调用 <code>x264_quant_function_t</code> 的 <code>quant_4x4x4()</code> 汇编函数进行量化。</li>
<li>c)分成 16 个 <code>4x4</code> 的块，对每个 <code>4x4</code> 块分别调用 <code>x264_quant_function_t</code> 的 <code>dequant_4x4()</code> 汇编函数进行反量化（用于重建帧）。</li>
<li>d)分成 4 个 <code>8x8</code> 的块，对每个 <code>8x8</code> 块分别调用 <code>x264_dct_function_t</code> 的 <code>add8x8_idct()</code> 汇编函数，对残差进行 DCT 反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。</li>
</ul>
<p>（5）    如果对色度编码，调用 <code>x264_mb_encode_chroma()</code> 。</p>
<p>从 Inter 宏块编码的步骤可以看出，编码就是 “DCT变换+量化” 两步的组合。</p>
<p>简单整理一下 <code>x264_mb_encode_i16x16()</code> 的逻辑，如下所示：</p>
<p>（1）调用 <code>predict_16x16[]()</code> 汇编函数对重建宏块数据 <code>p_fdec</code> 进行帧内预测。</p>
<p>（2）调用 <code>x264_dct_function_t</code> 的 <code>sub16x16_dct()</code> 汇编函数，计算重建宏块数据 <code>p_fdec</code> 与编码宏块数据<code>p_fenc</code> 之间的残差，然后对残差做 DCT 变换。</p>
<p>（3）抽取出来 16 个 <code>4x4DCT</code> 小块的 DC 系数，存储于 <code>dct_dc4x4[]</code>。</p>
<p>（4）分成 4 个 <code>8x8</code> 的块，对每个 <code>8x8</code> 块分别调用 <code>x264_quant_function_t</code> 的 <code>quant_4x4x4()</code> 汇编函数进行量化。</p>
<p>（5）分成 16 个 <code>4x4</code> 的块，对每个 <code>4x4</code> 块分别调用 <code>x264_quant_function_t</code> 的 <code>dequant_4x4()</code> 汇编函数进行反量化（用于重建帧）。</p>
<p>（6）对于 <code>dct_dc4x4[]</code> 中 16 个小块的 DC 系数作如下处理：</p>
<ul>
<li>a)调用 <code>x264_dct_function_t</code> 的 <code>dct4x4dc()</code> 汇编函数进行 Hadamard 变换。</li>
<li>b)调用 <code>x264_quant_function_t</code> 的 <code>quant_4x4_dc()</code> 汇编函数进行 DC 系数的量化。</li>
<li>c)调用 <code>x264_dct_function_t</code> 的 <code>idct4x4dc()</code> 汇编函数进行 Hadamard 反变换。</li>
<li>d)调用 <code>x264_quant_function_t</code> 的 <code>dequant_4x4_dc()</code> 汇编函数进行 DC 系数的反量化。</li>
<li>e)将反量化后的 DC 系数重新放到 <code>16x16</code> 块对应的位置上。</li>
</ul>
<p>（7）调用 <code>x264_dct_function_t</code> 的 <code>add16x16_idct()</code> 汇编函数，对残差进行 DCT 反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。</p>
<p>可以看出 <code>Intra16x16</code> 编码的过程就是一个 “DCT变换 + 量化 + Hadamard变换” 的流程。其中 “DCT变换 + 量化” 是一个通用的编码步骤，而 “Hadamard变换” 是专属于 <code>Intra16x16</code> 宏块的步骤。</p>
<p>简单整理一下 <code>x264_mb_encode_i4x4()</code> 的逻辑，如下所示：</p>
<p>（1）调用 <code>predict_4x4[]()</code> 汇编函数对重建宏块数据 <code>p_fdec</code> 进行帧内预测。</p>
<p>（2）调用 <code>x264_dct_function_t</code> 的 <code>sub4x4_dct ()</code> 汇编函数，计算重建宏块数据 <code>p_fdec</code> 与编码宏块数据 <code>p_fenc</code> 之间的残差，然后对残差做 DCT 变换。</p>
<p>（3）调用 <code>x264_quant_function_t</code> 的 <code>quant_4x4()</code> 汇编函数进行量化。</p>
<p>（4）调用 <code>x264_quant_function_t</code> 的 <code>dequant_4x4()</code> 汇编函数进行反量化（用于重建帧）。</p>
<p>（5）调用 <code>x264_dct_function_t</code> 的 <code>add4x4_idct()</code> 汇编函数，对残差进行 DCT 反变换，并将反变换后的数据叠加（“add”）至预测数据上（用于重建帧）。</p>
<p>可以看出 <code>Intra4x4</code> 编码的过程就是一个 “DCT变换 + 量化” 的流程。</p>
<h2 id="熵编码（Entropy-Encoding）部分"><a href="#熵编码（Entropy-Encoding）部分" class="headerlink" title="熵编码（Entropy Encoding）部分"></a>熵编码（Entropy Encoding）部分</h2><p><code>x264_macroblock_write_cavlc()</code> 对应着x264中的熵编码模块。熵编码模块主要完成了编码数据输出的功能。</p>
<h3 id="函数调用关系图-7"><a href="#函数调用关系图-7" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="熵编码（Entropy Encoding）部分的函数调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/x264_macroblock_write_cavlc.png" data-index="19" data-src="/images/imageFFmpeg/Thor/x264_macroblock_write_cavlc.png"></p>
<p>从图中可以看出，熵编码模块包含两个函数 <code>x264_macroblock_write_cabac()</code> 和<code>x264_macroblock_write_cavlc()</code>。如果输出设置为 CABAC 编码，则会调用<code>x264_macroblock_write_cabac()</code>；如果输出设置为 CAVLC 编码，则会调用 <code>x264_macroblock_write_cavlc()</code> 。本文选择 CAVLC 编码输出函数 <code>x264_macroblock_write_cavlc()</code> 进行分析。该函数调用了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x264_cavlc_mb_header_i()		<span class="comment">// 写入I宏块MB Header数据。包含帧内预测模式等。</span></span><br><span class="line">x264_cavlc_mb_header_p()		<span class="comment">// 写入P宏块MB Header数据。包含MVD、参考帧序号等。</span></span><br><span class="line">x264_cavlc_mb_header_b()		<span class="comment">// 写入B宏块MB Header数据。包含MVD、参考帧序号等。</span></span><br><span class="line">x264_cavlc_qp_delta()			<span class="comment">// 写入QP。</span></span><br><span class="line">x264_cavlc_block_residual()		<span class="comment">// 写入残差数据。</span></span><br></pre></td></tr></table></figure>
<p>从源代码可以看出，<code>x264_macroblock_write_cavlc()</code> 的流程大致如下：</p>
<p>（1）根据 Slice 类型的不同，调用不同的函数输出宏块头（MB Header）：</p>
<ul>
<li>a)对于 <code>P Slice</code>，调用 <code>x264_cavlc_mb_header_p()</code></li>
<li>b)对于 <code>B Slice</code>，调用 <code>x264_cavlc_mb_header_b()</code></li>
<li>c)对于 <code>I Slice</code>，调用 <code>x264_cavlc_mb_header_i()</code></li>
</ul>
<p>（2）调用 <code>x264_cavlc_qp_delta()</code> 输出宏块 QP 值</p>
<p>（3）调用 <code>x264_cavlc_block_residual()</code> 输出 CAVLC 编码的残差数据</p>
<h2 id="FFmpeg与libx264接口源代码简单分析"><a href="#FFmpeg与libx264接口源代码简单分析" class="headerlink" title="FFmpeg与libx264接口源代码简单分析"></a>FFmpeg与libx264接口源代码简单分析</h2><p>本文简单记录一下 FFmpeg 的 libavcodec 中与 libx264 接口部分的源代码。该部分源代码位于 “libavcodec/libx264.c” 中。正是有了这部分代码，使得 FFmpeg 可以调用 libx264 编码 H.264 视频。</p>
<h3 id="函数调用关系图-8"><a href="#函数调用关系图-8" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="FFmpeg的libavcodec中的libx264.c的函数调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/[FFmpeg的libavcodec中的libx264的函数调用关系.png" data-index="20" data-src="/images/imageFFmpeg/Thor/[FFmpeg的libavcodec中的libx264的函数调用关系.png"></p>
<p>从图中可以看出，libx264 对应的 AVCodec 结构体 <code>ff_libx264_encoder</code> 中设定编码器初始化函数是 <code>X264_init()</code>，编码一帧数据的函数是 <code>X264_frame()</code>，编码器关闭函数是 <code>X264_close()</code>。</p>
<p><code>X264_init()</code> 调用了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[libx264 API] x264_param_default()			<span class="comment">// 设置默认参数。</span></span><br><span class="line">[libx264 API] x264_param_default_preset()	<span class="comment">// 设置默认preset。</span></span><br><span class="line">convert_pix_fmt() 	<span class="comment">// 将FFmpeg像素格式转换为libx264像素格式。</span></span><br><span class="line">[libx264 API] x264_param_apply_profile()	<span class="comment">// 设置Profile。</span></span><br><span class="line">[libx264 API] x264_encoder_open()			<span class="comment">// 打开编码器。</span></span><br><span class="line">[libx264 API] x264_encoder_headers()		<span class="comment">// 需要全局头的时候，输出头信息。</span></span><br></pre></td></tr></table></figure>
<p>X264_frame()调用了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[libx264 API] x264_encoder_encode()				<span class="comment">// 编码一帧数据。</span></span><br><span class="line">[libx264 API] x264_encoder_delayed_frames()		<span class="comment">// 输出编码器中缓存的数据。</span></span><br><span class="line">encode_nals() 	<span class="comment">// 将编码后得到的x264_nal_t转换为AVPacket。</span></span><br></pre></td></tr></table></figure>
<p><code>X264_close()</code> 调用了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[libx264 API] x264_encoder_close()	<span class="comment">// 关闭编码器。</span></span><br></pre></td></tr></table></figure>
<h1 id="解码-libavcodec-H-264-解码器"><a href="#解码-libavcodec-H-264-解码器" class="headerlink" title="解码 - libavcodec H.264 解码器"></a>解码 - libavcodec H.264 解码器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>本文简单记录 FFmpeg 中 libavcodec 的 H.264 解码器（H.264 Decoder）的源代码。这个 H.264 解码器十分重要，可以说 FFmpeg 项目今天可以几乎“垄断”视音频编解码技术，很大一部分贡献就来自于这个 H.264 解码器。这个 H.264 解码器一方面功能强大，性能稳定；另一方面源代码也比较复杂，难以深入研究。本文打算梳理一下这个 H.264 解码器的源代码结构，以方便以后深入学习 H.264 使用。</p>
<blockquote>
<p>PS：这部分代码挺复杂的，还有不少地方还比较模糊，还需要慢慢学习……</p>
</blockquote>
<h3 id="函数调用关系图-9"><a href="#函数调用关系图-9" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p>H.264解码器的函数调用关系图如下所示。</p>
<p><img alt="H.264解码器的函数调用关系图" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/H.264解码器的函数调用关系图.png" data-index="21" data-src="/images/imageFFmpeg/Thor/H.264解码器的函数调用关系图.png"></p>
<p>下面解释一下图中关键标记的含义。</p>
<h4 id="作为接口的结构体"><a href="#作为接口的结构体" class="headerlink" title="作为接口的结构体"></a>作为接口的结构体</h4><p>FFmpeg和H.264解码器之间作为接口的结构体有2个：</p>
<ul>
<li><code>ff_h264_parser</code>：用于解析 H.264 码流的 AVCodecParser 结构体。</li>
<li><code>ff_h264_decoder</code>：用于解码 H.264 码流的 AVCodec 结构体。</li>
</ul>
<h4 id="函数背景色-1"><a href="#函数背景色-1" class="headerlink" title="函数背景色"></a>函数背景色</h4><p>函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用：</p>
<ul>
<li>白色背景的函数：普通内部函数。</li>
<li>粉红色背景函数：解析函数（Parser）。这些函数用于解析SPS、PPS等信息。</li>
<li>紫色背景的函数：熵解码函数（Entropy Decoding）。这些函数读取码流数据并且进行CABAC或者CAVLC熵解码。</li>
<li>绿色背景的函数：解码函数（Decode）。这些函数通过帧内预测、帧间预测、DCT反变换等方法解码压缩数据。</li>
<li>黄色背景的函数：环路滤波函数（Loop Filter）。这些函数对解码后的数据进行滤波，去除方块效应。</li>
<li>蓝色背景函数：汇编函数（Assembly）。这些函数是做过汇编优化的函数。图中主要画出了这些函数的C语言版本，此外这些函数还包含MMX版本、SSE版本、NEON版本等。</li>
</ul>
<h4 id="箭头线-1"><a href="#箭头线-1" class="headerlink" title="箭头线"></a>箭头线</h4><p>箭头线标志了函数的调用关系：</p>
<ul>
<li>黑色箭头线：不加区别的调用关系。</li>
<li>粉红色的箭头线：解析函数（Parser）之间的调用关系。</li>
<li>紫色箭头线：熵解码函数（Entropy Decoding）之间的调用关系。</li>
<li>绿色箭头线：解码函数（Decode）之间的调用关系。</li>
<li>黄色箭头线：环路滤波函数（Loop Filter）之间的调用关系。</li>
</ul>
<h4 id="函数所在的文件-1"><a href="#函数所在的文件-1" class="headerlink" title="函数所在的文件"></a>函数所在的文件</h4><p>每个函数标识了它所在的文件路径。</p>
<h3 id="几个关键部分"><a href="#几个关键部分" class="headerlink" title="几个关键部分"></a>几个关键部分</h3><p>下文简单记录几个关键的部分。</p>
<h4 id="FFmpeg和H-264解码器之间作为接口的结构体"><a href="#FFmpeg和H-264解码器之间作为接口的结构体" class="headerlink" title="FFmpeg和H.264解码器之间作为接口的结构体"></a>FFmpeg和H.264解码器之间作为接口的结构体</h4><p>FFmpeg和H.264解码器之间作为接口的结构体有2个：ff_h264_parser和ff_h264_decoder。</p>
<p><strong>ff_h264_parser</strong></p>
<p>ff_h264_parser是用于解析H.264码流的AVCodecParser结构体。AVCodecParser中包含了几个重要的函数指针：</p>
<ul>
<li><strong>parser_init()：初始化解析器。</strong></li>
<li><strong>parser_parse()：解析。</strong></li>
<li><strong>parser_close()：关闭解析器。</strong></li>
</ul>
<p>在ff_h264_parser结构体中，上述几个函数指针分别指向下面几个实现函数：</p>
<ul>
<li><strong>init()：初始化H.264解析器。</strong></li>
<li><strong>h264_parse()：解析H.264码流。</strong></li>
<li><strong>close()：关闭H.264解析器。</strong></li>
</ul>
<p><strong>ff_h264_decoder</strong></p>
<p>ff_h264_decoder是用于解码H.264码流的AVCodec结构体。AVCodec中包含了几个重要的函数指针：</p>
<ul>
<li><strong>init()：初始化解码器。</strong></li>
<li><strong>decode()：解码。</strong></li>
<li><strong>close()：关闭解码器。</strong></li>
</ul>
<p>在ff_h264_decoder结构体中，上述几个函数指针分别指向下面几个实现函数：</p>
<ul>
<li><strong>ff_h264_decode_init()：初始化H.264解码器。</strong></li>
<li><p><strong>h264_decode_frame()：解码H.264码流。</strong></p>
</li>
<li><p><strong>h264_decode_end()：关闭H.264解码器。</strong></p>
</li>
</ul>
<h4 id="普通内部函数"><a href="#普通内部函数" class="headerlink" title="普通内部函数"></a>普通内部函数</h4><p>普通内部函数指的是H.264解码器中还没有进行分类的函数。下面举几个例子。</p>
<p>ff_h264_decoder中ff_h264_decode_init()调用的初始化函数：</p>
<ul>
<li><strong>ff_h264dsp_init()：初始化DSP相关的函数。包含了IDCT、环路滤波函数等。</strong></li>
<li><strong>ff_h264qpel_init()：初始化四分之一像素运动补偿相关的函数。</strong></li>
<li><strong>ff_h264_pred_init()：初始化帧内预测相关的函数。</strong></li>
<li><strong>ff_h264_decode_extradata()：解析AVCodecContext中的extradata。</strong></li>
</ul>
<p>ff_h264_decoder中h264_decode_frame()逐层调用的和解码Slice相关的函数：</p>
<ul>
<li><strong>decode_nal_units()，ff_h264_execute_decode_slices()，decode_slice()等。</strong></li>
</ul>
<p>ff_h264_decoder中h264_decode_end()调用的清理函数：</p>
<ul>
<li><strong>ff_h264_remove_all_refs()：移除所有参考帧。</strong></li>
<li><strong>ff_h264_free_context()：释放在初始化H.264解码器的时候分配的内存。</strong></li>
</ul>
<p>ff_h264_parser中h264_parse()逐层调用的和解析Slice相关的函数：</p>
<ul>
<li><p><strong>h264_find_frame_end()：查找NALU的结尾。</strong></p>
</li>
<li><p><strong>parse_nal_units()：解析一个NALU。</strong></p>
</li>
</ul>
<h4 id="解析函数（Parser）"><a href="#解析函数（Parser）" class="headerlink" title="解析函数（Parser）"></a><font style="color:rgb(255,153,255);">解析函数（Parser）</font></h4><p>解析函数（Parser）用于解析H.264码流中的一些信息（例如SPS、PPS、Slice Header等）。在parse_nal_units()和decode_nal_units()中都调用这些解析函数完成了解析。下面举几个解析函数的例子。</p>
<ul>
<li><strong>ff_h264_decode_nal()：解析NALU。这个函数是后几个解析函数的前提。</strong></li>
<li><strong>ff_h264_decode_slice_header()：解析Slice Header。</strong></li>
<li><strong>ff_h264_decode_sei()：解析SEI。</strong></li>
<li><strong>ff_h264_decode_seq_parameter_set()：解析SPS。</strong></li>
<li><strong>ff_h264_decode_picture_parameter_set()：解析PPS。</strong></li>
</ul>
<h4 id="熵解码函数（Entropy-Decoding）"><a href="#熵解码函数（Entropy-Decoding）" class="headerlink" title="熵解码函数（Entropy Decoding）"></a><font style="color:#993399;">熵解码函数（Entropy Decoding）</font></h4><p>熵解码函数（Entropy Decoding）读取码流数据并且进行CABAC或者CAVLC熵解码。CABAC解码函数是ff_h264_decode_mb_cabac()，CAVLC解码函数是ff_h264_decode_mb_cavlc()。熵解码函数中包含了很多的读取指数哥伦布编码数据的函数，例如get_ue_golomb_long()，get_ue_golomb()，get_se_golomb()，get_ue_golomb_31()等等。</p>
<p>在获取残差数据的时候需要进行CAVLC/CABAC解码。例如解码CAVLC的时候，会调用decode_residual()函数，而decode_residual()会调用get_vlc2()函数，get_vlc2()会调用OPEN_READER()，UPDATE_CACHE()，GET_VLC()，CLOSE_READER()几个函数读取CAVLC格式的数据。<br>此外，在获取运动矢量的时候，会调用pred_motion()以及类似的几个函数获取运动矢量相关的信息。</p>
<h4 id="解码函数（Decode）"><a href="#解码函数（Decode）" class="headerlink" title="解码函数（Decode）"></a><font style="color:#009900;">解码函数（Decode）</font></h4><p>解码函数（Decode）通过帧内预测、帧间预测、DCT反变换等方法解码压缩数据。解码函数是<code>ff_h264_hl_decode_mb()</code>。其中跟宏块类型的不同，会调用几个不同的函数，最常见的就是调用<code>hl_decode_mb_simple_8()</code>。</p>
<p><code>hl_decode_mb_simple_8()</code> 的定义是无法在源代码中直接找到的，这是因为它实际代码的函数名称是使用宏的方式写的（以后再具体分析）。<code>hl_decode_mb_simple_8()</code>的源代码实际上就是 <code>FUNC(hl_decode_mb)()</code> 函数的源代码。</p>
<p><code>FUNC(hl_decode_mb)()</code>根据宏块类型的不同作不同的处理：如果宏块类型是INTRA，就会调用<code>hl_decode_mb_predict_luma()</code> 进行帧内预测；如果宏块类型不是INTRA，就会调用<code>FUNC(hl_motion_422)()</code> 或者 <code>FUNC(hl_motion_420)()</code> 进行四分之一像素运动补偿。</p>
<p>随后 <code>FUNC(hl_decode_mb)()</code> 会调用 <code>hl_decode_mb_idct_luma()</code> 等几个函数对数据进行DCT反变换工作。</p>
<h4 id="环路滤波函数（Loop-Filter）"><a href="#环路滤波函数（Loop-Filter）" class="headerlink" title="环路滤波函数（Loop Filter）"></a><font style="color:#ffcc00;">环路滤波函数（Loop Filter）</font></h4><p>环路滤波函数（Loop Filter）对解码后的数据进行滤波，去除方块效应。环路滤波函数是loop_filter()。其中调用了ff_h264_filter_mb()和ff_h264_filter_mb_fast()。ff_h264_filter_mb_fast()中又调用了h264_filter_mb_fast_internal()。而h264_filter_mb_fast_internal()中又调用了下面几个函数进行滤波：</p>
<ul>
<li><strong>filter_mb_edgeh()：亮度水平滤波</strong></li>
<li><strong>filter_mb_edgev()：亮度垂直滤波</strong></li>
<li><p><strong>filter_mb_edgech()：色度水平滤波</strong></p>
</li>
<li><p><strong>filter_mb_edgecv()：色度垂直滤波</strong></p>
</li>
</ul>
<h4 id="汇编函数（Assembly）"><a href="#汇编函数（Assembly）" class="headerlink" title="汇编函数（Assembly）"></a><font style="color:#3333ff;">汇编函数（Assembly）</font></h4><p>汇编函数（Assembly）是做过汇编优化的函数。为了提高效率，整个H.264解码器中（主要在解码部分和环路滤波部分）包含了大量的汇编函数。实际解码的过程中，FFmpeg会根据系统的特性调用相应的汇编函数（而不是C语言函数）以提高解码的效率。如果系统不支持汇编优化的话，FFmpeg才会调用C语言版本的函数。例如在帧内预测的时候，对于16x16亮度DC模式，有以下几个版本的函数：</p>
<ul>
<li>C语言版本的pred16x16_dc_8_c()</li>
<li>NEON版本的ff_pred16x16_dc_neon()</li>
<li>MMXEXT版本的ff_pred16x16_dc_8_mmxext()</li>
<li>SSE2版本的ff_pred16x16_dc_8_sse2()</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>在网上找到一张图（出处不详），分析了FFmpeg的H.264解码器每个函数运行的耗时情况，比较有参考意义，在这里附上。</p>
<p><img alt="H.264解码器每个函数运行的耗时情况" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/H.264解码器每个函数运行的耗时情况.png" data-index="22" data-src="/images/imageFFmpeg/Thor/H.264解码器每个函数运行的耗时情况.png"></p>
<p>从图中可以看出，熵解码、宏块解码、环路滤波耗时比例分别为：23.64%、51.85%、22.22%。</p>
<h2 id="解析器（Parser）部分"><a href="#解析器（Parser）部分" class="headerlink" title="解析器（Parser）部分"></a>解析器（Parser）部分</h2><p>本文继续分析FFmpeg中libavcodec的H.264解码器（H.264 Decoder）。上篇文章概述了FFmpeg中H.264解码器的结构；从这篇文章开始，具体研究H.264解码器的源代码。本文分析H.264解码器中解析器（Parser）部分的源代码。这部分的代码用于分割H.264的NALU，并且解析SPS、PPS、SEI等信息。解析H.264码流（对应AVCodecParser结构体中的函数）和解码H.264码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相应的功能。</p>
<h3 id="函数调用关系图-10"><a href="#函数调用关系图-10" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="解析器（Parser）部分的源代码的调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/解析器部分的源代码的调用关系.png" data-index="23" data-src="/images/imageFFmpeg/Thor/解析器部分的源代码的调用关系.png"></p>
<p>从图中可以看出，H.264的解析器（Parser）在解析数据的时候调用 <code>h264_parse()</code>，<code>h264_parse()</code> 调用了<code>parse_nal_units()</code>，<code>parse_nal_units()</code> 则调用了一系列解析特定 NALU 的函数。H.264 的解码器（Decoder）在解码数据的时候调用 <code>h264_decode_frame()</code>，<code>h264_decode_frame()</code> 调用了<code>decode_nal_units()</code>，<code>decode_nal_units()</code> 也同样调用了一系列解析不同 NALU 的函数。</p>
<p>图中简单列举了几个解析特定 NALU 的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff_h264_decode_nal()					<span class="comment">// 解析 NALU Header</span></span><br><span class="line">ff_h264_decode_seq_parameter_set()		<span class="comment">// 解析 SPS</span></span><br><span class="line">ff_h264_decode_picture_parameter_set()	<span class="comment">// 解析 PPS</span></span><br><span class="line">ff_h264_decode_sei()					<span class="comment">// 解析 SEI</span></span><br></pre></td></tr></table></figure>
<p>H.264 解码器与 H.264 解析器最主要的不同的地方在于它调用了 <code>ff_h264_execute_decode_slices()</code> 函数进行了解码工作。这篇文章只分析 H.264 解析器的源代码，至于 H.264 解码器的源代码，则在后面几篇文章中再进行分析。</p>
<h4 id="h264-find-frame-end"><a href="#h264-find-frame-end" class="headerlink" title="h264_find_frame_end()"></a>h264_find_frame_end()</h4><p><code>h264_find_frame_end()</code> 用于查找 H.264 码流中的 “起始码”（start code）。在 H.264 码流中有两种起始码： <code>0x000001</code> 和 <code>0x00000001</code>。其中 4Byte 的长度的起始码最为常见。只有当一个完整的帧被编为多个 slice 的时候，包含这些 slice 的 NALU 才会使用 3Byte 的起始码。<code>h264_find_frame_end()</code> 的定义位于<code>libavcodec\h264_parser.c</code></p>
<p>从源代码可以看出，<code>h264_find_frame_end()</code> 使用了一种类似于状态机的方式查找起始码。函数中的 <code>for()</code> 循环每执行一遍，状态机的状态就会改变一次。该状态机主要包含以下几种状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7 - 初始化状态</span><br><span class="line">2 - 找到1个0</span><br><span class="line">1 - 找到2个0</span><br><span class="line">0 - 找到大于等于3个0</span><br><span class="line">4 - 找到2个0和1个1，即001（即找到了起始码）</span><br><span class="line">5 - 找到至少3个0和1个1，即0001等等（即找到了起始码）</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">=8 - 找到2个Slice Header</span></span><br></pre></td></tr></table></figure>
<p>这些状态之间的状态转移图如下所示。图中粉红色代表初始状态，绿色代表找到“起始码”的状态。</p>
<p><img alt="状态之间的状态转移" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/h264_find_frame_end状态转移.png" data-index="24" data-src="/images/imageFFmpeg/Thor/h264_find_frame_end状态转移.png"></p>
<p>如图所示，<code>h264_find_frame_end()</code> 初始化时候位于状态 “7”；当找到 1 个 “0” 之后，状态从 “7” 变为 “2”；在状态 “2” 下，如果再次找到 1 个 “0”，则状态变为 “1”；在状态 “1” 下，如果找到 “1”，则状态变换为 “4”，表明找到了 “0x000001” 起始码；在状态 “1” 下，如果找到 “0”，则状态变换为 “0”；在状态 “0” 下，如果找到 “1”，则状态变换为 “5” ，表明找到了 “0x000001” 起始码。</p>
<p><code>parse_nal_units()</code> 主要做了以下几步处理：</p>
<p>（1）对于所有的 NALU，都调用 <code>ff_h264_decode_nal</code> 解析 NALU 的 Header，得到 nal_unit_type 等信息</p>
<p>（2）根据 nal_unit_type 的不同，调用不同的解析函数进行处理。例如：</p>
<ul>
<li>a)解析 SPS 的时候调用 <code>ff_h264_decode_seq_parameter_set()</code></li>
<li>b)解析 PPS 的时候调用 <code>ff_h264_decode_picture_parameter_set()</code></li>
<li><p>c)解析 SEI 的时候调用 <code>ff_h264_decode_sei()</code></p>
</li>
<li><p>d)解析 IDR Slice / Slice 的时候，获取 slice_type 等一些信息。</p>
</li>
</ul>
<h2 id="解码器主干部分"><a href="#解码器主干部分" class="headerlink" title="解码器主干部分"></a>解码器主干部分</h2><p>本文分析FFmpeg的H.264解码器的主干部分。“主干部分” 是相对于 “熵解码”、“宏块解码”、“环路滤波” 这些细节部分而言的。它包含了 H.264 解码器直到 <code>decode_slice()</code> 前面的函数调用关系（<code>decode_slice()</code> 后面就是H.264解码器的细节部分，主要包含了 “熵解码”、“宏块解码”、“环路滤波” 3个部分）。</p>
<h3 id="函数调用关系图-11"><a href="#函数调用关系图-11" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="解码器主干部分的源代码的调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/解码器主干部分的源代码的调用关系.png" data-index="25" data-src="/images/imageFFmpeg/Thor/解码器主干部分的源代码的调用关系.png"></p>
<p>从图中可以看出，H.264解码器（Decoder）在初始化的时候调用了 <code>ff_h264_decode_init()</code>，<code>ff_h264_decode_init()</code> 又调用了下面几个函数进行解码器汇编函数的初始化工作（仅举了几个例子）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ff_h264dsp_init()		<span class="comment">// 初始化DSP相关的汇编函数。包含了IDCT、环路滤波函数等。</span></span><br><span class="line">ff_h264qpel_init()		<span class="comment">// 初始化四分之一像素运动补偿相关的汇编函数。</span></span><br><span class="line">ff_h264_pred_init()		<span class="comment">// 初始化帧内预测相关的汇编函数。</span></span><br></pre></td></tr></table></figure>
<p>H.264 解码器在关闭的时候调用了 <code>h264_decode_end()</code>，<code>h264_decode_end()</code> 又调用了<code>ff_h264_remove_all_refs()</code>，<code>ff_h264_free_context()</code> 等几个函数进行清理工作。<br>H.264 解码器在解码图像帧的时候调用了 <code>h264_decode_frame()</code>，<code>h264_decode_frame()</code> 调用了 <code>decode_nal_units()</code>，<code>decode_nal_units()</code> 调用了两类函数——解析函数和解码函数，如下所示。</p>
<p>（1）解析函数（获取信息）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ff_h264_decode_nal()				<span class="comment">// 解析NALU Header。</span></span><br><span class="line">ff_h264_decode_seq_parameter_set()	<span class="comment">// 解析SPS。</span></span><br><span class="line">ff_h264_decode_picture_parameter_set()	<span class="comment">// 解析PPS。</span></span><br><span class="line">ff_h264_decode_sei()	<span class="comment">// 解析SEI。</span></span><br><span class="line">ff_h264_decode_slice_header()	<span class="comment">// 解析Slice Header。</span></span><br></pre></td></tr></table></figure>
<p>（2）解码函数（解码获得图像）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ff_h264_execute_decode_slices() 	<span class="comment">// 解码Slice。</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>ff_h264_execute_decode_slices()</code> 调用了 <code>decode_slice()</code>，而 <code>decode_slice()</code> 中调用了解码器中细节处理的函数（暂不详细分析）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff_h264_decode_mb_cabac()	<span class="comment">// CABAC熵解码函数。</span></span><br><span class="line">ff_h264_decode_mb_cavlc()	<span class="comment">// CAVLC熵解码函数。</span></span><br><span class="line">ff_h264_hl_decode_mb()		<span class="comment">// 宏块解码函数。</span></span><br><span class="line">loop_filter()				<span class="comment">// 环路滤波函数。</span></span><br></pre></td></tr></table></figure>
<p><code>h264_decode_frame()</code> 根据输入的 AVPacket 的 data 是否为空作不同的处理：</p>
<p>（1）若果输入的 AVPacket 的 data 为空，则调用 <code>output_frame()</code> 输出 <code>delayed_pic[]</code> 数组中的H264Picture，即输出解码器中缓存的帧（对应的是通常称为 “Flush Decoder” 的功能）。</p>
<p>（2）若果输入的 AVPacket 的 data 不为空，则首先调用 <code>decode_nal_units()</code> 解码 AVPacket 的 data，然后再调用 <code>output_frame()</code> 输出解码后的视频帧（有一点需要注意：由于帧重排等因素，输出的 AVFrame 并非对应于输入的 AVPacket）。</p>
<p><code>decode_nal_units()</code> 首先调用 <code>ff_h264_decode_nal()</code> 判断 NALU 的类型，然后根据 NALU 类型的不同调用了不同的处理函数。这些处理函数可以分为两类——解析函数和解码函数，如下所示。</p>
<p>（1）解析函数（获取信息）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ff_h264_decode_seq_parameter_set()		<span class="comment">// 解析SPS。</span></span><br><span class="line">ff_h264_decode_picture_parameter_set()	<span class="comment">// 解析PPS。</span></span><br><span class="line">ff_h264_decode_sei()					<span class="comment">// 解析SEI。</span></span><br><span class="line">ff_h264_decode_slice_header()			<span class="comment">// 解析Slice Header。</span></span><br></pre></td></tr></table></figure>
<p>（2）解码函数（解码得到图像）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ff_h264_execute_decode_slices()	<span class="comment">// 解码Slice。</span></span><br></pre></td></tr></table></figure>
<p><code>decode_slice()</code> 按照宏块（<code>16x16</code>）的方式处理输入的视频流。每个宏块的压缩数据经过以下 3 个基本步骤的处理，得到解码后的数据：</p>
<p>（1）熵解码。如果熵编码为 CABAC，则调用 <code>ff_h264_decode_mb_cabac()</code>；如果熵编码为 CAVLC，则调用 <code>ff_h264_decode_mb_cavlc()</code></p>
<p>（2）宏块解码。这一步骤调用 <code>ff_h264_hl_decode_mb()</code></p>
<p>（3）环路滤波。这一步骤调用 <code>loop_filter()</code></p>
<p>此外，还有可能调用错误隐藏函数 <code>er_add_slice()</code>。</p>
<p>至此，<code>decode_nal_units()</code> 函数的调用流程就基本分析完毕了。<code>h264_decode_frame()</code> 在调用完 <code>decode_nal_units()</code> 之后，还需要把解码后得到的 H264Picture 转换为 AVFrame 输出出来，这时候会调用一个相对比较简单的函数 <code>output_frame()</code>。</p>
<h2 id="熵解码（Entropy-Decoding）部分"><a href="#熵解码（Entropy-Decoding）部分" class="headerlink" title="熵解码（Entropy Decoding）部分"></a>熵解码（Entropy Decoding）部分</h2><p>FFmpeg的H.264解码器调用 <code>decode_slice()</code> 函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第1个步骤。</p>
<h3 id="函数调用关系图-12"><a href="#函数调用关系图-12" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="熵解码（Entropy Decoding）部分的源代码的调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/熵解码部分的源代码的调用关系.png" data-index="26" data-src="/images/imageFFmpeg/Thor/熵解码部分的源代码的调用关系.png"></p>
<p>从图中可以看出，FFmpeg的熵解码方面的函数有两个：<code>ff_h264_decode_mb_cabac()</code> 和 <code>ff_h264_decode_mb_cavlc()</code>。</p>
<ul>
<li><code>ff_h264_decode_mb_cabac()</code> 用于解码 CABAC 编码方式的 H.264 数据，</li>
<li><code>ff_h264_decode_mb_cavlc()</code>用于解码 CAVLC 编码方式的 H.264 数据。</li>
</ul>
<p>本文挑选了<code>ff_h264_decode_mb_cavlc()</code> 函数进行分析。</p>
<p><code>ff_h264_decode_mb_cavlc()</code> 调用了很多的读取指数哥伦布编码数据的函数，例如 <code>get_ue_golomb_long()</code>，<code>get_ue_golomb()，get_se_golomb()</code>，<code>get_ue_golomb_31()</code> 等。此外在解码残差数据的时候，调用了 <code>decode_residual()</code>函数，而 <code>decode_residual()</code> 会调用 <code>get_vlc2()</code> 函数读取 CAVLC 编码数据。</p>
<p>总而言之，“熵解码” 部分的作用就是按照 H.264 语法和语义的规定，读取数据（宏块类型、运动矢量、参考帧、残差等）并且赋值到 FFmpeg H.264 解码器中相应的变量上。需要注意的是，“熵解码” 部分并不使用这些变量还原视频数据。还原视频数据的功能在下一步 “宏块解码” 步骤中完成。</p>
<p>在开始看 <code>ff_h264_decode_mb_cavlc()</code> 之前先回顾一下 <code>decode_slice()</code> 函数。</p>
<p><code>decode_slice()</code> 的的流程如下：</p>
<p>（1）判断 H.264 码流是 CABAC 编码还是 CAVLC 编码，进入不同的处理循环。</p>
<p>（2）如果是 CABAC 编码，首先调用 <code>ff_init_cabac_decoder()</code> 初始化 CABAC 解码器。然后进入一个循环，依次对每个宏块进行以下处理：</p>
<ul>
<li><p>a)调用 <code>ff_h264_decode_mb_cabac()</code>进行 CABAC 熵解码</p>
</li>
<li><p>b)调用 <code>ff_h264_hl_decode_mb()</code> 进行宏块解码</p>
</li>
<li><p>c)解码一行宏块之后调用 <code>loop_filter()</code> 进行环路滤波</p>
</li>
<li><p>d)此外还有可能调用 <code>er_add_slice()</code> 进行错误隐藏处理</p>
</li>
</ul>
<p>（3）如果是 CABAC 编码，直接进入一个循环，依次对每个宏块进行以下处理：</p>
<ul>
<li><p>a)调用 <code>ff_h264_decode_mb_cavlc()</code> 进行 CAVLC 熵解码</p>
</li>
<li><p>b)调用 <code>ff_h264_hl_decode_mb()</code> 进行宏块解码</p>
</li>
<li><p>c)解码一行宏块之后调用 <code>loop_filter()</code> 进行环路滤波</p>
</li>
<li><p>d)此外还有可能调用 <code>er_add_slice()</code> 进行错误隐藏处理</p>
</li>
</ul>
<p>可以看出，出了熵解码以外，宏块解码和环路滤波的函数是一样的。</p>
<p><code>ff_h264_decode_mb_cavlc()</code> 的定义有将近 1000 行代码，算是一个比较复杂的函数了。我在其中写了不少注释，因此不再对源代码进行详细的分析。下面先简单梳理一下它的流程：</p>
<p>（1）解析 Skip 类型宏块</p>
<p>（2）获取 <code>mb_type</code></p>
<p>（3）填充当前宏块左边和上边宏块的信息（后面的预测中会用到）</p>
<p>（4）根据 <code>mb_type</code> 的不同，分成三种情况进行预测工作：</p>
<ul>
<li><p>a)宏块是帧内预测</p>
<ul>
<li>i.如果宏块是 <code>Intra4x4</code> 类型，则需要单独解析帧内预测模式。</li>
<li>ii.如果宏块是 <code>Intra16x16</code> 类型，则不再做过多处理。</li>
</ul>
</li>
<li><p>b)宏块划分为 4 个块（此时每个 <code>8x8</code> 的块可以再次划分为 4 种类型）</p>
<p>这个时候每个 <code>8x8</code> 的块可以再次划分为 <code>8x8、8x4、4x8、4x4</code> 几种子块。需要分别处理这些小的子块：</p>
<ul>
<li>i.解析子块的参考帧序号</li>
<li>ii.解析子块的运动矢量</li>
</ul>
</li>
<li><p>c)其它类型（包括 <code>16x16，16x8，8x16</code> 几种划分，这些划分不可再次划分）</p>
<p>这个时候需要判断宏块的类型为 <code>16x16，16x8</code> 还是 <code>8x16</code>，然后作如下处理：</p>
<ul>
<li>i.解析子宏块的参考帧序号</li>
<li>ii.解析子宏块的运动矢量</li>
</ul>
</li>
</ul>
<p>（5）解码残差信息</p>
<p>（6）将宏块的各种信息输出到整个图片相应的变量中</p>
<h4 id="各种-Cache（缓存）"><a href="#各种-Cache（缓存）" class="headerlink" title="各种 Cache（缓存）"></a>各种 Cache（缓存）</h4><p>在 H.264 解码器中包含了各种各样的 Cache（缓存）。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intra4x4_pred_mode_cache	<span class="comment">// Intra4x4帧内预测模式的缓存</span></span><br><span class="line">non_zero_count_cache		<span class="comment">// 每个4x4块的非0系数个数的缓存</span></span><br><span class="line">mv_cache					<span class="comment">// 运动矢量缓存</span></span><br><span class="line">ref_cache					<span class="comment">// 运动矢量参考帧的缓存</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/leixiaohua1020/article/details/45114453" target="_blank" rel="noopener">其他知识查看</a></p>
</blockquote>
<h2 id="宏块解码（Decode）部分-帧内宏块（Intra）"><a href="#宏块解码（Decode）部分-帧内宏块（Intra）" class="headerlink" title="宏块解码（Decode）部分-帧内宏块（Intra）"></a>宏块解码（Decode）部分-帧内宏块（Intra）</h2><p>FFmpeg的H.264解码器调用 <code>decode_slice()</code> 函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第2个步骤。由于宏块解码部分的内容比较多，因此将本部分内容拆分成两篇文章：一篇文章记录帧内预测宏块（Intra）的宏块解码，另一篇文章记录帧间预测宏块（Inter）的宏块解码。</p>
<h3 id="函数调用关系图-13"><a href="#函数调用关系图-13" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="宏块解码（Decode）部分的源代码的调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/宏块解码部分的源代码的调用关系.png" data-index="27" data-src="/images/imageFFmpeg/Thor/宏块解码部分的源代码的调用关系.png"></p>
<p>宏块解码函数（Decode）通过帧内预测、帧间预测、DCT 反变换等方法解码压缩数据。解码函数是 <code>ff_h264_hl_decode_mb()</code>。其中跟宏块类型的不同，会调用几个不同的函数，最常见的就是调用 <code>hl_decode_mb_simple_8()</code>。</p>
<p><code>hl_decode_mb_simple_8()</code> 的定义是无法在源代码中直接找到的，这是因为它实际代码的函数名称是使用宏的方式写的。<code>hl_decode_mb_simple_8()</code> 的源代码实际上就是 <code>FUNC(hl_decode_mb)()</code> 函数的源代码。</p>
<p>从函数调用图中可以看出，<code>FUNC(hl_decode_mb)()</code> 根据宏块类型的不同作不同的处理：</p>
<ul>
<li>如果帧内预测宏块（INTRA），就会调用 <code>hl_decode_mb_predict_luma()</code> 进行帧内预测；</li>
<li>如果是帧间预测宏块（INTER），就会调用 <code>FUNC(hl_motion_422)()</code> 或者 <code>FUNC(hl_motion_420)()</code> 进行四分之一像素运动补偿。</li>
</ul>
<p>经过帧内预测或者帧间预测步骤之后，就得到了预测数据。随后 <code>FUNC(hl_decode_mb)()</code> 会调用 <code>hl_decode_mb_idct_luma()</code> 等几个函数对残差数据进行 DCT 反变换工作，并将变换后的数据叠加到预测数据上，形成解码后的图像数据。</p>
<p>由于帧内预测宏块和帧间预测宏块的解码工作都比较复杂，因此分成两篇文章记录这两部分的源代码。本文记录帧内预测宏块解码时候的源代码。</p>
<p>下面简单梳理一下 <code>FUNC(hl_decode_mb)</code> 的流程（在这里只考虑亮度分量的解码，色度分量的解码过程是类似的）：</p>
<p>（1）预测</p>
<ul>
<li>a)如果是帧内预测宏块（Intra），调用 <code>hl_decode_mb_predict_luma()</code> 进行帧内预测，得到预测数据。</li>
<li>b)如果不是帧内预测宏块（Inter），调用 <code>FUNC(hl_motion_420)()</code> 或者 <code>FUNC(hl_motion_422)()</code> 进行帧间预测（即运动补偿），得到预测数据。</li>
</ul>
<p>（2）残差叠加</p>
<ul>
<li>a)调用 <code>hl_decode_mb_idct_luma()</code> 对 DCT 残差数据进行 DCT 反变换，获得残差像素数据并且叠加到之前得到的预测数据上，得到最后的图像数据。</li>
</ul>
<p>PS：该流程中有一个重要的贯穿始终的内存指针 <code>dest_y</code>，其指向的内存中存储了解码后的亮度数据。</p>
<p>根据原代码梳理一下 <code>hl_decode_mb_predict_luma()</code> 的主干：</p>
<p>（1）如果宏块是4x4帧内预测类型（Intra4x4），作如下处理：</p>
<ul>
<li>a)循环遍历 16 个 <code>4x4</code> 的块，并作如下处理：<ul>
<li>i.从 <code>intra4x4_pred_mode_cache</code> 中读取 <code>4x4</code> 帧内预测方法</li>
<li>ii.根据帧内预测方法调用 H264PredContext 中的汇编函数 <code>pred4x4()</code> 进行帧内预测</li>
<li>iii.调用 H264DSPContext 中的汇编函数 <code>h264_idct_add()</code> 对 DCT 残差数据进行 <code>4x4DCT</code> 反变换；如果DCT 系数中不包含 AC 系数的话，则调用汇编函数 <code>h264_idct_dc_add()</code> 对残差数据进行 <code>4x4DCT</code> 反变换（速度更快）。</li>
</ul>
</li>
</ul>
<p>（2）如果宏块是 <code>16x16</code> 帧内预测类型（<code>Intra4x4</code>），作如下处理：</p>
<ul>
<li>a)通过 <code>intra16x16_pred_mode</code> 获得 <code>16x16</code> 帧内预测方法</li>
<li>b)根据帧内预测方法调用 H264PredContext 中的汇编函数 <code>pred16x16 ()</code> 进行帧内预测</li>
<li>c)调用 H264DSPContext 中的汇编函数 <code>h264_luma_dc_dequant_idct ()</code> 对 16 个小块的 DC 系数进行Hadamard 反变换</li>
</ul>
<p>在这里需要注意，帧内 <code>4x4</code> 的宏块在执行完 <code>hl_decode_mb_predict_luma()</code> 之后实际上已经完成了 “帧内预测+DCT反变换” 的流程（解码完成）；而帧内 <code>16x16</code> 的宏块在执行完 <code>hl_decode_mb_predict_luma()</code> 之后仅仅完成了 “帧内预测+Hadamard反变换 ”的流程，而并未进行 “DCT反变换” 的步骤，这一步骤需要在后续步骤中完成。</p>
<p>下文记录上述流程中涉及到的汇编函数（此处暂不记录DCT反变换的函数，在后文中再进行叙述）：</p>
<ul>
<li><code>4x4</code>帧内预测汇编函数：<code>H264PredContext -&gt; pred4x4[dir</code>]()</li>
<li><p><code>16x16</code> 帧内预测汇编函数：<code>H264PredContext -&gt; pred16x16[dir]()</code></p>
</li>
<li><p>Hadamard反变换汇编函数：<code>H264DSPContext-&gt;h264_luma_dc_dequant_idct()</code></p>
</li>
</ul>
<p>下面根据源代码简单梳理一下 <code>hl_decode_mb_idct_luma()</code> 的流程：</p>
<p>（1）判断宏块是否属于 <code>Intra4x4</code> 类型，如果是，函数直接返回（<code>Intra4x4</code> 比较特殊，它的 DCT 反变换已经前文所述的 “帧内预测” 部分完成）。</p>
<p>（2）根据不同的宏块类型作不同的处理：</p>
<ul>
<li>a) <code>Intra16x16</code>：调用 H264DSPContext 的汇编函数 <code>h264_idct_add16intra()</code> 进行 DCT 反变换</li>
<li>b) Inter类型：调用 H264DSPContext 的汇编函数 <code>h264_idct_add16()</code> 进行 DCT 反变换</li>
</ul>
<p>PS：需要注意的是 <code>h264_idct_add16intra()</code> 和 <code>h264_idct_add16()</code> 只有微小的区别，它们的基本逻辑都是把 <code>16x16</code> 的块划分为 16 个 <code>4x4</code> 的块再进行 DCT 反变换。此外还有一点需要注意：函数名中的 “add” 的含义是将 DCT 反变换之后的残差像素数据直接叠加到已有数据之上。</p>
<h2 id="宏块解码（Decode）部分-帧间宏块（Inter）"><a href="#宏块解码（Decode）部分-帧间宏块（Inter）" class="headerlink" title="宏块解码（Decode）部分-帧间宏块（Inter）"></a>宏块解码（Decode）部分-帧间宏块（Inter）</h2><p>本文分析FFmpeg的H.264解码器的宏块解码（Decode）部分。FFmpeg的H.264解码器调用 <code>decode_slice()</code> 函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第2个步骤：宏块解码。上一篇文章已经记录了帧内预测宏块（Intra）的宏块解码，本文继续上一篇文章的内容，记录帧间预测宏块（Inter）的宏块解码。</p>
<h3 id="函数调用关系图-14"><a href="#函数调用关系图-14" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p>参考宏块解码（Decode）部分的源代码的调用关系图</p>
<p><code>MCFUNC(hl_motion)</code> 根据子宏块的划分类型的不同，传递不同的参数调用 <code>mc_part()</code> 函数。</p>
<p>（1）如果子宏块划分为 <code>16x16</code>（等同于没有划分），直接调用 <code>mc_part()</code> 并且传递如下参数：</p>
<ul>
<li>a)单向预测汇编函数集：<code>qpix_put[0]</code> （<code>qpix_put[0]</code>中的函数进行 <code>16x16</code> 块的四分之一像素运动补偿）。</li>
<li>b)双向预测汇编函数集：<code>qpix_avg[0]</code>。</li>
<li>c) square 设置为 1，delta 设置为 0。</li>
<li>d) x_offset 和 y_offset 都设置为 0。</li>
</ul>
<p>（2）如果子宏块划分为 <code>16x8</code>，分两次调用 <code>mc_part()</code> 并且传递如下参数：</p>
<ul>
<li>a)单向预测汇编函数集：<code>qpix_put[1]</code> （<code>qpix_put[1]</code> 中的函数进行 <code>8x8</code> 块的四分之一像素运动补偿）。</li>
<li>b)双向预测汇编函数集：<code>qpix_avg[1]</code>。</li>
<li>c) square 设置为 0，delta 设置为 8。</li>
</ul>
<p>其中第 1 次调用 <code>mc_part()</code> 的时候 x_offset 和 y_offset 都设置为 0，第 2 次调用 <code>mc_part()</code> 的时候 x_offset 设置为 0，y_offset 设置为 4。</p>
<p>（3）如果子宏块划分为 <code>8x16</code>，分两次调用 <code>mc_part()</code> 并且传递如下参数：</p>
<ul>
<li>a)单向预测汇编函数集：<code>qpix_put[1]</code> （<code>qpix_put[1]</code> 中的函数进行 <code>8x8</code> 块的四分之一像素运动补偿）。</li>
<li>b)双向预测汇编函数集：<code>qpix_avg[1]</code>。</li>
<li>c) square设置为 0，delta 设置为 <code>8 * h-&gt;mb_linesize</code>。</li>
</ul>
<p>其中第 1 次调用 <code>mc_part()</code> 的时候 x_offset 和 y_offset 都设置为 0，第 2 次调用 <code>mc_part()</code> 的时候 x_offset 设置为 4，y_offset 设置为 0。</p>
<p>（4）如果子宏块划分为 <code>8x8</code>，说明此时每个 <code>8x8</code> 子宏块还可以继续划分为 <code>8x8，8x8，4x8，4x4</code> 几种类型，此时根据上述的规则，分成 4 次分别对这些小块做类似的处理。</p>
<p><code>qpix_put[4][16]</code> 实际上指向了 H264QpelContex 的 <code>put_h264_qpel_pixels_tab[4][16]</code> ，其中存储了所有单向预测方块的四分之一像素运动补偿函数。其中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qpix_put[0]存储的是16x16方块的运动补偿函数；</span><br><span class="line">qpix_put[1]存储的是8x8方块的运动补偿函数；</span><br><span class="line">qpix_put[2]存储的是4x4方块的运动补偿函数；</span><br><span class="line">qpix_put[3]存储的是2x2方块的运动补偿函数；</span><br></pre></td></tr></table></figure>
<p>从源代码可以看出，<code>mc_part_std()</code> 首先计算了几个关键的用于确定子宏块位置的参数，然后根据预测类型的不同（单向预测或者双向预测），把不同的函数指针传递给 <code>mc_dir_part()</code>：如果仅仅使用了 list0（单向预测），则只传递 <code>qpix_put()</code>；如果使用了 list0 和 list1（双向预测），则调用两次 <code>mc_dir_part()</code>，第一次传递 <code>qpix_put()</code>，第二次传递 <code>qpix_avg()</code>。</p>
<p><code>mc_part_std()</code> 中赋值了 3 个重要的变量（只考虑亮度）：</p>
<p>（1）<code>dest_y</code>：指向子宏块亮度数据指针。这个值是通过 x_offset 和 y_offset 计算得来的。在这里需要注意一点：x_offset 和 y_offset 是以色度为基本单位的，所以在计算亮度相关的变量的时候需要乘以 2。</p>
<p>（2）<code>x_offset</code>：传入的 x_offset 本来是子宏块相对于整个宏块位置的横坐标，在这里加上 <code>8 * h-&gt;mb_x</code> 之后，变成了子宏块相对于整个图像的位置的横坐标（以色度为基本单位）。</p>
<p>（3）<code>y_offset</code>：传入的 y_offset 本来是子宏块相对于整个宏块位置的纵坐标，在这里加上 <code>8 * h-&gt;mb_y</code> 之后，变成了子宏块相对于整个图像的位置的纵坐标（以色度为基本单位）。</p>
<p>通过源代码，简单梳理一下 <code>mc_dir_part()</code> 的流程（只考虑亮度，色度的流程类似）：</p>
<p>（1）计算 mx 和 my。mx 和 my 是当前宏块的匹配块的位置坐标。需要注意的是该坐标是以 <code>1/4</code> 像素（而不是整像素）为基本单位的。</p>
<p>（2）计算 offset。offset 是当前宏块的匹配块相对于图像的整像素偏移量，由 mx、my 计算而来。</p>
<p>（3）计算 luma_xy。luma_xy 决定了当前宏块的匹配块采用的四分之一像素运动补偿的方式，由 mx、my 计算而来。</p>
<p>（4）调用运动补偿汇编函数 <code>qpix_op[luma_xy]()</code> 完成运动补偿。在这里需要注意，如果子宏块不是正方形的（square 取 0），则还会调用 1 次 <code>qpix_op[luma_xy]()</code> 完成另外一个方块的运动补偿。</p>
<p>总而言之，首先找到当前宏块的匹配块的整像素位置，然后在该位置的基础上进行四分之一像素的内插，并将结果输出出来。</p>
<p>前文中曾经提过，由于 H.264 解码器中只提供了正方形块的四分之一像素运动补偿函数，所以如果子宏块不是正方形的（例如 <code>16x8，8x16</code>），就需要先将子宏块划分为正方形的方块，然后再进行两次运动补偿（两个正方形方块之间的位置关系用 delta 变量记录）。例如 <code>16x8</code> 的宏块，就会划分成两个 <code>8x8</code> 的方块，调用两次相同的运动补偿函数</p>
<p>下面可以看一下 C 语言版本的四分之一像素运动补偿函数的源代码。由于 <code>1/4</code> 像素内插比较复杂，其中还用到了整像素赋值函数以及 <code>1/2</code> 像素线性内插函数，所以需要从简到难一步一步的看这些源代码。打算按照顺序一步一步分析这些源代码：</p>
<p>（1）pel_template.c（展开“ <code>DEF_PEL(put, op_put)</code> ”宏）：整像素赋值（用于整像素的单向预测）</p>
<p>（2）pel_template.c（展开“ <code>DEF_PEL(avg, op_avg)</code> ”宏）：整像素求平均（写这个为了举一个双向预测的例子）</p>
<p>（3）hpel_template.c(（展开“<code>DEF_HPEL(put, op_put)</code>”宏）：<code>1/2</code> 像素线性内插</p>
<p>（4）h264qpel_template.c（展开“ <code>H264_LOWPASS(put_, op_put, op2_put)</code>”宏）：半像素内插（注意不是1/2像素线性内插，而是需要滤波的）</p>
<p>（5）h264qpel_template.c（展开“<code>H264_MC(put_, 8)</code>”宏）：<code>1/4</code>像素运动补偿</p>
<h2 id="环路滤波（Loop-Filter）部分"><a href="#环路滤波（Loop-Filter）部分" class="headerlink" title="环路滤波（Loop Filter）部分"></a>环路滤波（Loop Filter）部分</h2><p>本文分析FFmpeg的H.264解码器的环路滤波（Loop Filter）部分。FFmpeg的H.264解码器调用decode_slice()函数完成了解码工作。这些解码工作可以大体上分为3个步骤：熵解码，宏块解码以及环路滤波。本文分析这3个步骤中的第3个步骤。</p>
<h3 id="函数调用关系图-15"><a href="#函数调用关系图-15" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h3><p><img alt="环路滤波（Loop Filter）部分的源代码的调用关系" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/环路滤波部分的源代码的调用关系.png" data-index="28" data-src="/images/imageFFmpeg/Thor/环路滤波部分的源代码的调用关系.png"></p>
<p>环路滤波主要用于滤除方块效应。<code>decode_slice()</code> 在解码完一行宏块之后，会调用 <code>loop_filter()</code> 函数完成环路滤波功能。<code>loop_filter()</code> 函数会遍历该行宏块中的每一个宏块，并且针对每一个宏块调用 <code>ff_h264_filter_mb_fast()</code>。<code>ff_h264_filter_mb_fast()</code> 又会调用 <code>h264_filter_mb_fast_internal()</code>。</p>
<p><code>h264_filter_mb_fast_internal()</code> 完成了一个宏块的环路滤波工作。该函数调用 <code>filter_mb_edgev()</code> 和 <code>filter_mb_edgeh()</code> 对亮度垂直边界和水平边界进行滤波，或者调用 <code>filter_mb_edgecv()</code> 和 <code>filter_mb_edgech()</code> 对色度的的垂直边界和水平边界进行滤波。</p>
<p>通过源代码整理出来 <code>h264_filter_mb_fast_internal()</code> 的流程如下：</p>
<p>（1）读取 QP 等几个参数，用于推导滤波门限值 alpha，beta。</p>
<p>（2）如果是帧内宏块（Intra），作如下处理：</p>
<ul>
<li><p>a)对于水平的边界，调用 <code>filter_mb_edgeh()</code> 进行滤波。</p>
</li>
<li><p>b)对于垂直的边界，调用 <code>filter_mb_edgev()</code> 进行滤波。</p>
<p>帧内宏块滤波过程中，对于在宏块边界上的边界（最左边的垂直边界和最上边的水平边界），采用滤波强度 Bs 为 4 的滤波；对于其它边界则采用滤波强度 Bs 为 3 的滤波。</p>
</li>
</ul>
<p>（3）如果是其他宏块，作如下处理：</p>
<ul>
<li><p>a)对于水平的边界，调用 <code>filter_mb_edgeh()</code> 进行滤波。</p>
</li>
<li><p>b)对于垂直的边界，调用 <code>filter_mb_edgev()</code> 进行滤波。</p>
<p>此类宏块的滤波强度需要另作判断。</p>
</li>
</ul>
<p>总体说来，一个宏块内部的滤波顺序如下图所示。图中的 “0”、“1”、“2”、“3” 为滤波的顺序。可以看出首先对垂直边界进行滤波，然后对水平边界进行滤波。垂直边界滤波按照从左到右的顺序进行，而水平边界的滤波按照从上到下的顺序进行。</p>
<p><img alt="宏块内部的滤波顺序" class="post-img b-lazy" data-img="/images/imageFFmpeg/Thor/宏块内部的滤波顺序.png" data-index="29" data-src="/images/imageFFmpeg/Thor/宏块内部的滤波顺序.png"></p>
<h1 id="H-264-中的-NAL-技术"><a href="#H-264-中的-NAL-技术" class="headerlink" title="H.264 中的 NAL 技术"></a>H.264 中的 NAL 技术</h1><h2 id="NAL-技术"><a href="#NAL-技术" class="headerlink" title="NAL 技术"></a>NAL 技术</h2><h3 id="NAL-概述"><a href="#NAL-概述" class="headerlink" title="NAL 概述"></a>NAL 概述</h3><p>NAL 全称 Network Abstract Layer，即网络抽象层。在 H.264/AVC 视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL）和网络抽象层面（NAL）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。</p>
<p>现实中的传输系统是多样化的，其可靠性，服务质量，封装方式等特征各不相同，NAL 这一概念的提出提供了一个视频编码器和传输系统的友好接口，使得编码后的视频数据能够有效地在各种不同的网络环境中传输。</p>
<h3 id="NAL-单元"><a href="#NAL-单元" class="headerlink" title="NAL 单元"></a>NAL 单元</h3><p>NAL 单元是 NAL 的基本语法结构，它包含一个字节的头信息和一系列来自 VCL 的称为原始字节序列载荷<br>（RBSP）的字节流。头信息中包含着一个可否丢弃的指示标记，标识着该 NAL 单元的丢弃能否引起错误扩散，一般，如果 NAL 单元中的信息不用于构建参考图像，则认为可以将其丢弃；最后包含的是NAL 单元的类型信息，暗示着其内含有效载荷的内容。 送到解码器端的 NAL 单元必须遵守严格的顺序，如果应用程序接收到的 NAL 单元处于乱序，则必须提供一种恢复其正确顺序的方法。</p>
<h3 id="NAL-实现编解码器与传输网络的结合"><a href="#NAL-实现编解码器与传输网络的结合" class="headerlink" title="NAL 实现编解码器与传输网络的结合"></a>NAL 实现编解码器与传输网络的结合</h3><p>NAL 提供了一个编解码器与传输网络的通用接口，而对于不同的网络环境，具体的实现方案是不同的。对于基于流的传输系统如 H.320、MPEG 等，需要按照解码顺序组织 NAL 单元，并为每个 NAL 单元增加若干比特字节对齐的前缀以形成字节流；对于 RTP/UDP/IP 系统，则可以直接将编码器输出的 NAL 单元作为 RTP 的有效载荷；而对于同时提供多个逻辑信道的传输系统，甚至可以根据重要性将不同类型的NAL 单元在不同服务质量的信道中传输。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>为了实现编解码器良好的网络适应性，需要做两方面的工作：</p>
<p>第一、在 Codec 中将 NAL 这一技术完整而有效的实现；</p>
<p>第二、在遵循 H.264/AVC NAL 规范的前提下设计针对不同网络的最佳传输方案。</p>
<p>如果实现了以上两个目标，所实现的就不仅仅是一种视频编解码技术，而是一套适用范围很广的多媒体传输方案，该方案适用于如视频会议，数据存储，电视广播，流媒体，无线通信，远程监控等多种领域。</p>
<h2 id="NALU-类型"><a href="#NALU-类型" class="headerlink" title="NALU 类型"></a>NALU 类型</h2><p>标识 NAL 单元中的 RBSP 数据类型，其中，nal_unit_type 为 1， 2， 3， 4， 5 的 NAL 单元称为 VCL 的 NAL单元，其他类型的 NAL 单元为非 VCL 的 NAL 单元。</p>
<ul>
<li>0：未规定</li>
<li>1：非 IDR 图像中不采用数据划分的片段</li>
<li>2：非 IDR 图像中 A 类数据划分片段</li>
<li>3：非 IDR 图像中 B 类数据划分片段</li>
<li>4：非 IDR 图像中 C 类数据划分片段</li>
<li>5：IDR 图像的片段</li>
<li>6：补充增强信息（SEI）</li>
<li>7：序列参数集（SPS）</li>
<li>8：图像参数集（PPS）</li>
<li>9：分割符</li>
<li>10：序列结束符</li>
<li>11：流结束符</li>
<li>12：填充数据</li>
<li>13：序列参数集扩展</li>
<li>14：带前缀的 NAL 单元</li>
<li>15：子序列参数集</li>
<li>16 – 18：保留</li>
<li>19：不采用数据划分的辅助编码图像片段</li>
<li>20：编码片段扩展</li>
<li>21 – 23：保留</li>
<li>24 – 31：未规定</li>
</ul>
<h3 id="SPS-详析"><a href="#SPS-详析" class="headerlink" title="SPS 详析"></a>SPS 详析</h3><p>TODO</p>
<h3 id="PPS-详析"><a href="#PPS-详析" class="headerlink" title="PPS 详析"></a>PPS 详析</h3><p>TODO</p>
<h3 id="SEI-详析"><a href="#SEI-详析" class="headerlink" title="SEI 详析"></a>SEI 详析</h3><p>TODO</p>
<h2 id="NAL-在多媒体传输、存储系统中的应用"><a href="#NAL-在多媒体传输、存储系统中的应用" class="headerlink" title="NAL 在多媒体传输、存储系统中的应用"></a>NAL 在多媒体传输、存储系统中的应用</h2><p>NAL 的头占用了一个字节，按照比特自高至低排列可以表示如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0AABBBBB</span><br></pre></td></tr></table></figure>
<p>其中，AA 用于表示该 NAL 是否可以丢弃（有无被其后的 NAL 参考），00b 表示没有参考作用，可丢弃，如 B slice、SEI 等，非零——包括 01b、10b、11b——表示该 NAL 不可丢弃，如 SPS、PPS、I Slice、P Slice 等。</p>
<p>常用的 NAL 头的取值如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x67: SPS</span><br><span class="line">0x68: PPS</span><br><span class="line">0x65: IDR</span><br><span class="line">0x61: non-IDR Slice</span><br><span class="line">0x01: B Slice</span><br><span class="line">0x06: SEI</span><br><span class="line">0x09: AU Delimiter</span><br></pre></td></tr></table></figure>
<p>由于 NAL 的语法中没有给出长度信息，实际的传输、存储系统需要增加额外的头实现各个 NAL 单元的定界。其中，AVI 文件和 MPEG TS 广播流采取的是字节流的语法格式，即在 NAL 单元之前增加 0x00000001 的同步码，则从 AVI 文件或 MPEG TS PES 包中读出的一个 H.264 视频帧以下面的形式存在：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 01 06 ... 00 00 00 01 67 ... 00 00 00 01 68 ... 00 00 00 01 65 ...</span><br><span class="line">SEI 信息 			  SPS 				 PPS 				IDR Slice</span><br></pre></td></tr></table></figure>
<p>而对于 MP4 文件，NAL 单元之前没有同步码，却有若干字节的长度码，来表示 NAL 单元的长度，这个长度码所占用的字节数由 MP4 文件头给出；此外，从 MP4 读出来的视频帧不包含 PPS 和 SPS，这些信息位于 MP4的文件头中，解析器必须在打开文件的时候就获取它们。从 MP4 文件读出的一个 H.264 帧往往是下面的形式（假设长度码为 2 字节）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00 19 06 [... 25 字节...] 24 aa 65 [... 9386 字节...]</span><br><span class="line">SEI 信息 					IDR Slice</span><br></pre></td></tr></table></figure>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/FFmpeg/" rel="tag"># FFmpeg</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>

    
    <nav id="gobottom" class="pagination">
        
        <a class="prev-post" title="实用的计算机工具库" href="/2019-05-29/reference/实用的计算机工具库/">
            ← 实用的计算机工具库
        </a>
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="WebRTC开源src" href="/2019-05-27/reference/webrtc/webrtc-opensrc/">
            WebRTC开源src →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#编码-x264"><span class="toc-text">编码 - x264</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图"><span class="toc-text">函数调用关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数背景色"><span class="toc-text">函数背景色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区域"><span class="toc-text">区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头线"><span class="toc-text">箭头线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数所在的文件"><span class="toc-text">函数所在的文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几个关键的部分"><span class="toc-text">几个关键的部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x264命令行程序"><span class="toc-text">x264命令行程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libx264主干函数"><span class="toc-text">libx264主干函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x264-slice-write"><span class="toc-text">x264_slice_write()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#滤波模块"><span class="toc-text">滤波模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析模块"><span class="toc-text">分析模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#宏块编码模块"><span class="toc-text">宏块编码模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#熵编码模块"><span class="toc-text">熵编码模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#码率控制模块"><span class="toc-text">码率控制模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x264命令行工具"><span class="toc-text">x264命令行工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-1"><span class="toc-text">函数调用关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#main"><span class="toc-text">main()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parse"><span class="toc-text">parse()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#encode"><span class="toc-text">encode()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X264-控制台程序中和输入输出相关的结构体"><span class="toc-text">X264 控制台程序中和输入输出相关的结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码器主干部分"><span class="toc-text">编码器主干部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-2"><span class="toc-text">函数调用关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x264-encoder-open"><span class="toc-text">x264_encoder_open()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相关知识简述"><span class="toc-text">相关知识简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x264-encoder-headers"><span class="toc-text">x264_encoder_headers()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x264-encoder-close"><span class="toc-text">x264_encoder_close()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x264-encoder-encode"><span class="toc-text">x264_encoder_encode()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x264-slice-write-1"><span class="toc-text">x264_slice_write()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-3"><span class="toc-text">函数调用关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重要的数据结构"><span class="toc-text">重要的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#宏块像素存储缓存-fenc-buf-和-fdec-buf"><span class="toc-text">宏块像素存储缓存 fenc_buf[] 和 fdec_buf[]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏块各种信息的缓存Cache"><span class="toc-text">宏块各种信息的缓存Cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#滤波（Filter）部分"><span class="toc-text">滤波（Filter）部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-4"><span class="toc-text">函数调用关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏块分析（Analysis）部分-帧内宏块（Intra）"><span class="toc-text">宏块分析（Analysis）部分-帧内宏块（Intra）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-5"><span class="toc-text">函数调用关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏块分析（Analysis）部分-帧间宏块（Inter）"><span class="toc-text">宏块分析（Analysis）部分-帧间宏块（Inter）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏块编码（Encode）部分"><span class="toc-text">宏块编码（Encode）部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-6"><span class="toc-text">函数调用关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#熵编码（Entropy-Encoding）部分"><span class="toc-text">熵编码（Entropy Encoding）部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-7"><span class="toc-text">函数调用关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FFmpeg与libx264接口源代码简单分析"><span class="toc-text">FFmpeg与libx264接口源代码简单分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-8"><span class="toc-text">函数调用关系图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解码-libavcodec-H-264-解码器"><span class="toc-text">解码 - libavcodec H.264 解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述-1"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-9"><span class="toc-text">函数调用关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#作为接口的结构体"><span class="toc-text">作为接口的结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数背景色-1"><span class="toc-text">函数背景色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头线-1"><span class="toc-text">箭头线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数所在的文件-1"><span class="toc-text">函数所在的文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几个关键部分"><span class="toc-text">几个关键部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FFmpeg和H-264解码器之间作为接口的结构体"><span class="toc-text">FFmpeg和H.264解码器之间作为接口的结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#普通内部函数"><span class="toc-text">普通内部函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解析函数（Parser）"><span class="toc-text">解析函数（Parser）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#熵解码函数（Entropy-Decoding）"><span class="toc-text">熵解码函数（Entropy Decoding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解码函数（Decode）"><span class="toc-text">解码函数（Decode）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#环路滤波函数（Loop-Filter）"><span class="toc-text">环路滤波函数（Loop Filter）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#汇编函数（Assembly）"><span class="toc-text">汇编函数（Assembly）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#附录"><span class="toc-text">附录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析器（Parser）部分"><span class="toc-text">解析器（Parser）部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-10"><span class="toc-text">函数调用关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#h264-find-frame-end"><span class="toc-text">h264_find_frame_end()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解码器主干部分"><span class="toc-text">解码器主干部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-11"><span class="toc-text">函数调用关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#熵解码（Entropy-Decoding）部分"><span class="toc-text">熵解码（Entropy Decoding）部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-12"><span class="toc-text">函数调用关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#各种-Cache（缓存）"><span class="toc-text">各种 Cache（缓存）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏块解码（Decode）部分-帧内宏块（Intra）"><span class="toc-text">宏块解码（Decode）部分-帧内宏块（Intra）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-13"><span class="toc-text">函数调用关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#宏块解码（Decode）部分-帧间宏块（Inter）"><span class="toc-text">宏块解码（Decode）部分-帧间宏块（Inter）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-14"><span class="toc-text">函数调用关系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环路滤波（Loop-Filter）部分"><span class="toc-text">环路滤波（Loop Filter）部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数调用关系图-15"><span class="toc-text">函数调用关系图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#H-264-中的-NAL-技术"><span class="toc-text">H.264 中的 NAL 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NAL-技术"><span class="toc-text">NAL 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NAL-概述"><span class="toc-text">NAL 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAL-单元"><span class="toc-text">NAL 单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAL-实现编解码器与传输网络的结合"><span class="toc-text">NAL 实现编解码器与传输网络的结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NALU-类型"><span class="toc-text">NALU 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPS-详析"><span class="toc-text">SPS 详析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PPS-详析"><span class="toc-text">PPS 详析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEI-详析"><span class="toc-text">SEI 详析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NAL-在多媒体传输、存储系统中的应用"><span class="toc-text">NAL 在多媒体传输、存储系统中的应用</span></a></li></ol></li></ol>
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(/images/favicon-32x32-next.png)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; Pastor Dean &mdash;</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2020-01-16/thinking/Thinking modelBiological thinking Biological thinking looking at the business world from an evolutionary perspective/">Thinking modelBiological thinking Biological thinking: looking at the business world from an evolutionary perspective</a>
      </li>
      
      
      
      <li>
        <a href="/2020-01-13/thinking/Modern Darwin Integrated Model  Biological Thinking Mode Opening God Perspective/">Modern Darwin Integrated Model Biological Thinking Mode Opening God is Perspective</a>
      </li>
      
      
      
      <li>
        <a href="/2020-01-11/thinking/Metacognition Changing the stubborn thinking of the brain/">Metacognition Changing the stubborn thinking of the brain</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(/images/favicon-32x32-next.png)">
    <header class="read-next-card-header tagcloud-card">
        <h3 class="read-next-card-header-title">Categories</h3>
    </header>
    <div class="read-next-card-content">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Biological-Thinking/">Biological Thinking</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cognitive-Neuroscience/">Cognitive Neuroscience</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DeepLearning/">DeepLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FFmpeg/">FFmpeg</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MacOS/">MacOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MachineLearning/">MachineLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NLP/">NLP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PM/">PM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPC/">RPC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ubuntu/">Ubuntu</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebRTC/">WebRTC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/deeplearn/">deeplearn</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/machineLearning/">machineLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文摘/">文摘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构师/">架构师</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/知识图谱/">知识图谱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/职业规划/">职业规划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/职业规划/个人提升/">个人提升</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机基础/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机相关技术资料整理/">计算机相关技术资料整理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/认知升级/">认知升级</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/财务自由/">财务自由</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/财富自由/">财富自由</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(/images/favicon-32x32-next.png)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/AI/" style="font-size: 14px;">AI</a> <a href="/tags/Android/" style="font-size: 14px;">Android</a> <a href="/tags/Biological/" style="font-size: 17.75px;">Biological</a> <a href="/tags/Browser/" style="font-size: 14px;">Browser</a> <a href="/tags/Business/" style="font-size: 16.5px;">Business</a> <a href="/tags/Cognitive/" style="font-size: 17.75px;">Cognitive</a> <a href="/tags/DeepLearning/" style="font-size: 15.25px;">DeepLearning</a> <a href="/tags/Docker/" style="font-size: 14px;">Docker</a> <a href="/tags/FFmpeg/" style="font-size: 21.5px;">FFmpeg</a> <a href="/tags/FastCGI/" style="font-size: 14px;">FastCGI</a> <a href="/tags/IP划分/" style="font-size: 14px;">IP划分</a> <a href="/tags/IP地址/" style="font-size: 14px;">IP地址</a> <a href="/tags/Knowledge-Graph/" style="font-size: 16.5px;">Knowledge Graph</a> <a href="/tags/Linux-Shell/" style="font-size: 14px;">Linux Shell</a> <a href="/tags/MacOS/" style="font-size: 15.25px;">MacOS</a> <a href="/tags/Neuroscience/" style="font-size: 17.75px;">Neuroscience</a> <a href="/tags/RPC/" style="font-size: 14px;">RPC</a> <a href="/tags/Thinking/" style="font-size: 17.75px;">Thinking</a> <a href="/tags/Tutorial/" style="font-size: 20.25px;">Tutorial</a> <a href="/tags/WebRTC/" style="font-size: 21.5px;">WebRTC</a> <a href="/tags/WebSocket/" style="font-size: 14px;">WebSocket</a> <a href="/tags/algorithm/" style="font-size: 15.25px;">algorithm</a> <a href="/tags/config/" style="font-size: 14px;">config</a> <a href="/tags/decisionTree/" style="font-size: 14px;">decisionTree</a> <a href="/tags/git/" style="font-size: 17.75px;">git</a> <a href="/tags/google-adsense/" style="font-size: 14px;">google adsense</a> <a href="/tags/hexo/" style="font-size: 17.75px;">hexo</a> <a href="/tags/http/" style="font-size: 17.75px;">http</a> <a href="/tags/knn/" style="font-size: 14px;">knn</a> <a href="/tags/lighttpd/" style="font-size: 15.25px;">lighttpd</a> <a href="/tags/mxnet/" style="font-size: 14px;">mxnet</a> <a href="/tags/mysql/" style="font-size: 22.75px;">mysql</a> <a href="/tags/nlp/" style="font-size: 24px;">nlp</a> <a href="/tags/nodejs/" style="font-size: 14px;">nodejs</a> <a href="/tags/openvpn/" style="font-size: 14px;">openvpn</a> <a href="/tags/other/" style="font-size: 15.25px;">other</a> <a href="/tags/paddle/" style="font-size: 14px;">paddle</a> <a href="/tags/planning/" style="font-size: 20.25px;">planning</a> <a href="/tags/pracitce/" style="font-size: 15.25px;">pracitce</a> <a href="/tags/rich/" style="font-size: 14px;">rich</a> <a href="/tags/shell/" style="font-size: 14px;">shell</a> <a href="/tags/svn/" style="font-size: 14px;">svn</a> <a href="/tags/ubuntu/" style="font-size: 14px;">ubuntu</a> <a href="/tags/vim/" style="font-size: 16.5px;">vim</a> <a href="/tags/webpack/" style="font-size: 14px;">webpack</a> <a href="/tags/webrtc/" style="font-size: 19px;">webrtc</a> <a href="/tags/个人发展/" style="font-size: 14px;">个人发展</a> <a href="/tags/互联网实事/" style="font-size: 14px;">互联网实事</a> <a href="/tags/外链/" style="font-size: 14px;">外链</a> <a href="/tags/提升个人思维/" style="font-size: 14px;">提升个人思维</a> <a href="/tags/文摘/" style="font-size: 15.25px;">文摘</a> <a href="/tags/斜杠青年/" style="font-size: 14px;">斜杠青年</a> <a href="/tags/机器学习/" style="font-size: 16.5px;">机器学习</a> <a href="/tags/架构师/" style="font-size: 14px;">架构师</a> <a href="/tags/测试工具/" style="font-size: 14px;">测试工具</a> <a href="/tags/睡后成长/" style="font-size: 14px;">睡后成长</a> <a href="/tags/睡后收入/" style="font-size: 14px;">睡后收入</a> <a href="/tags/税后收入/" style="font-size: 14px;">税后收入</a> <a href="/tags/笔记/" style="font-size: 14px;">笔记</a> <a href="/tags/自然语言处理/" style="font-size: 24px;">自然语言处理</a> <a href="/tags/视频流/" style="font-size: 15.25px;">视频流</a> <a href="/tags/计算机相关技术资料整理/" style="font-size: 14px;">计算机相关技术资料整理</a> <a href="/tags/认知升级/" style="font-size: 14px;">认知升级</a> <a href="/tags/限速/" style="font-size: 14px;">限速</a> <a href="/tags/面试/" style="font-size: 14px;">面试</a> <a href="/tags/项目管理/" style="font-size: 14px;">项目管理</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="/images/favicon-16x16-next.png" alt="Pastor Dean">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="Pastor Dean">Pastor Dean &copy; 2020</a>
			
				
			        <span hidden="true" id="/2019-05-28/reference/FFmpeg/FFmpeg的H.264解码器源代码简单分析/" class="leancloud-visitors" data-flag-title="FFmpeg的H.264解码器源代码简单分析">
			            <span>阅读量 </span>
			            <span class="leancloud-visitors-count">0</span>
			        </span>
	    		
    		
		</div>
		<nav class="site-footer-nav">
			
			<a href="https://hexo.io" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>


<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>



<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>




<script id="valineScript" src="//unpkg.com/valine/dist/Valine.min.js" async></script>
<script>
    document.getElementById('valineScript').addEventListener("load", function() {
        new Valine({
            el: '#comment' ,
            verify: false,
            notify: false,
            appId: '',
            appKey: '',
            placeholder: 'Just go go',
            pageSize: 10,
            avatar: 'mm',
            visitor: true
        })
    });
</script>





</body>
</html>
